[{"content":"","date":"2024-09-15T00:59:34+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E4%BA%8B%E5%8A%A1%E4%B8%8Exlog/","title":"高性能MySql-事务与xlog"},{"content":"","date":"2024-09-15T00:58:54+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E7%B4%A2%E5%BC%95/","title":"高性能MySql-索引"},{"content":"","date":"2024-09-15T00:58:40+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E9%80%9A%E4%BF%A1/","title":"高性能MySql-通信"},{"content":"MySQL概览 关系型（行存储） 持久化（硬盘/外存） 事务支持（ACID） OLTP（on-line transaction processing） 通常用于主业务侧场景，例如电商购物、旅游购票、外卖下单等场景。\n区分于非主业务侧，会存在诸如商业分析、ai训练数据、用户画像等B端应用场景。此时MySQL也会被用作Data Lake数据湖的数据源，通过一些同步方式，例如binlog订阅、kafka-connector + 流式计算组件 flink/spark 传输至Elastic Search、Cassandra、Hbase等这样的OLAP（on-line analysis processing）大数据存储组件，而后B端工作人员基于这些OLAP组件进行后续的操作。\n架构 client/server\nbinlog\n流程 client端发起通信请求，通过tcp建立连接connection。 server端进行user/password鉴权（auth）。 数据库mysql的user表中进行验证。 验证通过后，通过mysql 的权限表（mysql中的 user、db、columns_privilege、Host 表，分别存储的是全局级别、数据库级别、表级别、列级别）查询当前用户的权限。 client端通过connection发送执行的sql脚本语句。 server端收到sql后对查询操作进行缓存判定（cache）。 在 MYSQL5.6以后默认关闭缓存，并且在 8.0 后功能置为Deprecated废弃，不推荐使用。原因是：在大多数使用场景下cache命中率过低（必须是两个完全一致的查询语句才能命中缓存）。 server端缓存未命中则进行sql解析（parser）。 from -\u0026gt; on -\u0026gt; join -\u0026gt; where -\u0026gt; group by -\u0026gt; having+聚合函数 -\u0026gt; select -\u0026gt; order by -\u0026gt; limit server端解析成功后优化器会根据索引信息选择相对最佳方案（optimizer）。 优化器会根据扫描行数、是否使用临时表、是否排序等来判断是否使用某个索引，其中扫描行数的计算可以通过统计信息来估算得出。 统计信息可以看作是索引唯一数的数量，mysql内部通过部分采样来估算：具体就是选择 N 个数据页，统计这些页上数据的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了。 由于索引数据会变化，所以索引的统计信息也会变化。当变更的数据行数超过 1/M 的时候，就会重新计算一次统计信息。也可以通过 \u0026ldquo;analyze table 表名\u0026rdquo; 来重新计算索引的统计信息。 统计信息是否持久化：通过innodb_stats_persistent，设置为 on 的时候，表示统计信息会持久化存储。持久化存储开启时，默认的 N 是 20，M 是 10。设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。 server端将优化器选择的索引方案交由存储引擎执行器进行数据查询（executor）。 server端将查询结果写入缓存 \u0026amp; 返回给client端。 client端接收到返回结果，完成sql操作。 如果client端是通过sdk（编程语言connector）进行连接，后续则可以通过一些orm框架进行table - model映射。 优化器 - 实操理解 建表 \u0026amp; 查询该表的统计信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 create table t_user( id bigint auto_increment comment \u0026#39;pk id\u0026#39; primary key, username varchar(256) not null, real_name varchar(32) default \u0026#39;\u0026#39; not null, nick_name varchar(32) default \u0026#39;\u0026#39; not null, password varchar(256) not null, phone_number varchar(16) default \u0026#39;\u0026#39; not null, locale varchar(8) default \u0026#39;\u0026#39; not null, country varchar(2) default \u0026#39;\u0026#39; not null ) comment \u0026#39;user table\u0026#39;; create index idx_country_locale_user on t_user (country, locale, username); create index idx_locale_user on t_user (locale, username); create index idx_real_name on t_user (real_name); select * from mysql.innodb_index_stats where table_name = \u0026#39;t_user\u0026#39;; 返回结果：\n# database_name table_name index_name last_update stat_name stat_value sample_size stat_description 1 db_rag_application t_user PRIMARY 2024/9/21 15:27 n_diff_pfx01 0 1 id 2 db_rag_application t_user PRIMARY 2024/9/21 15:27 n_leaf_pages 1 Number of leaf pages in the index 3 db_rag_application t_user PRIMARY 2024/9/21 15:27 size 1 Number of pages in the index 4 db_rag_application t_user idx_country_locale_user 2024/9/21 15:27 n_diff_pfx01 0 1 country 5 db_rag_application t_user idx_country_locale_user 2024/9/21 15:27 n_diff_pfx02 0 1 country,locale 6 db_rag_application t_user idx_country_locale_user 2024/9/21 15:27 n_diff_pfx03 0 1 country,locale,username 7 db_rag_application t_user idx_country_locale_user 2024/9/21 15:27 n_diff_pfx04 0 1 country,locale,username,id 8 db_rag_application t_user idx_country_locale_user 2024/9/21 15:27 n_leaf_pages 1 Number of leaf pages in the index 9 db_rag_application t_user idx_country_locale_user 2024/9/21 15:27 size 1 Number of pages in the index 10 db_rag_application t_user idx_locale_user 2024/9/21 15:27 n_diff_pfx01 0 1 locale 11 db_rag_application t_user idx_locale_user 2024/9/21 15:27 n_diff_pfx02 0 1 locale,username 12 db_rag_application t_user idx_locale_user 2024/9/21 15:27 n_diff_pfx03 0 1 locale,username,id 13 db_rag_application t_user idx_locale_user 2024/9/21 15:27 n_leaf_pages 1 Number of leaf pages in the index 14 db_rag_application t_user idx_locale_user 2024/9/21 15:27 size 1 Number of pages in the index 15 db_rag_application t_user idx_real_name 2024/9/21 15:27 n_diff_pfx01 0 1 real_name 16 db_rag_application t_user idx_real_name 2024/9/21 15:27 n_diff_pfx02 0 1 real_name,id 17 db_rag_application t_user idx_real_name 2024/9/21 15:27 n_leaf_pages 1 Number of leaf pages in the index 18 db_rag_application t_user idx_real_name 2024/9/21 15:27 size 1 Number of pages in the index 总结 MySQL会对表中的每个索引建立统计数据，存放在mysql.innodb_index_stats 表中，表字段相对清晰，不赘述。 普通索引（secondary/covering）含有n个字段时，会保存n+1条不同组合（额外增加id统计）的统计数据。 例如user表中key (country, locale, user)，产生4个统计数据记录 country, locale, user country, locale country country, locale, user, id 根据以上索引的统计数据，优化器可以找到相对最优的索引，而后进行execute查询数据。 MySQL优化经典操作 \u0026amp; 实现源码 mysql-server大部分操作源码位于sql目录下：https://github.com/mysql/mysql-server/tree/8.4/sql\nexplain 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 // ignore head include class Item; class Query_block; class Query_expression; class Query_term; class String; class THD; struct AccessPath; struct TABLE; template \u0026lt;class T\u0026gt; class mem_root_deque; extern const char *join_type_str[]; /** Table modification plan for JOIN-less statements (update/delete) */ class Modification_plan { public: THD *const thd; ///\u0026lt; Owning thread const enum_mod_type mod_type; ///\u0026lt; Modification type - MT_INSERT/MT_UPDATE/etc TABLE *table; ///\u0026lt; Table to modify enum join_type type = JT_UNKNOWN; AccessPath *range_scan{nullptr}; Item *condition{nullptr}; uint key; ///\u0026lt; Key to use ha_rows limit; ///\u0026lt; Limit bool need_tmp_table; ///\u0026lt; Whether tmp table needs to be used bool need_sort; ///\u0026lt; Whether to use filesort bool used_key_is_modified; ///\u0026lt; Whether the key used to scan is modified const char *message; ///\u0026lt; Arbitrary message bool zero_result; ///\u0026lt; true \u0026lt;=\u0026gt; plan will not be executed ha_rows examined_rows; ///\u0026lt; # of rows expected to be examined in the table Modification_plan(THD *thd_arg, enum_mod_type mt, TABLE *table_arg, enum join_type type_arg, AccessPath *quick_arg, Item *condition_arg, uint key_arg, ha_rows limit_arg, bool need_tmp_table_arg, bool need_sort_arg, bool used_key_is_modified_arg, ha_rows rows); Modification_plan(THD *thd_arg, enum_mod_type mt, TABLE *table_arg, const char *message_arg, bool zero_result_arg, ha_rows rows); ~Modification_plan(); private: void register_in_thd(); }; /** 这个类用于实现对 INSERT、REPLACE 和多表 UPDATE/DELETE 的 EXPLAIN 功能。它会在执行过程中取消对数据的实际修改。 通过重写 prepare()、start_execution() 和 cleanup() 方法，保证在准备和执行时调用底层的拦截器，但不会进行实际的数据修改。 原文（部分）：it suppresses table data modification by the underlying interceptor object. Thus, we can use Query_result_explain object in the context of EXPLAIN INSERT/ REPLACE/UPDATE/DELETE query like we use Query_result_send in the context of EXPLAIN SELECT command */ class Query_result_explain : public Query_result_send { protected: /** Pointer to underlying Query_result_insert, Query_result_update or Query_result_delete object. */ Query_result *interceptor; public: Query_result_explain(Query_expression *unit_arg, Query_result *interceptor_arg) : Query_result_send(), interceptor(interceptor_arg) { unit = unit_arg; } bool use_protocol_adapter() const override { return false; } protected: bool prepare(THD *thd, const mem_root_deque\u0026lt;Item *\u0026gt; \u0026amp;list, Query_expression *u) override { return Query_result_send::prepare(thd, list, u) || interceptor-\u0026gt;prepare(thd, list, u); } bool start_execution(THD *thd) override { return Query_result_send::start_execution(thd) || interceptor-\u0026gt;start_execution(thd); } void cleanup() override { Query_result_send::cleanup(); interceptor-\u0026gt;cleanup(); } }; /** * Wrapper class for writing EXPLAIN output to a user variable. * * This class overrides Query_result_send::send_data() to write the output of * the EXPLAIN query to the user variable specified by m_variable_name. */ class Query_result_explain_into_var final : public Query_result_explain { public: Query_result_explain_into_var(Query_expression *expr, Query_result *child, std::string_view variable_name) : Query_result_explain(expr, child), m_variable_name(variable_name) {} bool send_result_set_metadata(THD *, const mem_root_deque\u0026lt;Item *\u0026gt; \u0026amp;, uint) override { return false; } bool send_data(THD *thd, const mem_root_deque\u0026lt;Item *\u0026gt; \u0026amp;items) override; bool send_eof(THD *thd) override; private: std::string_view m_variable_name; }; // explain单表CUD写操作函数 bool explain_single_table_modification(THD *explain_thd, const THD *query_thd, const Modification_plan *plan, Query_block *select); // explain复杂CRUD操作函数 bool explain_query(THD *explain_thd, const THD *query_thd, Query_expression *unit); // 多个query block查询块（子查询，细节可查询query_term.h内容）时，会调用这个函数，相当于explain_query的进阶函数，可能会被explain_query多次调用 bool explain_query_specification(THD *explain_thd, const THD *query_thd, Query_term *query_term, enum_parsing_context ctx); class Sql_cmd_explain_other_thread final : public Sql_cmd { public: explicit Sql_cmd_explain_other_thread(my_thread_id thread_id) : m_thread_id(thread_id) {} enum_sql_command sql_command_code() const override { return SQLCOM_EXPLAIN_OTHER; } bool execute(THD *thd) override; private: /// connection_id in EXPLAIN FOR CONNECTION \\\u0026lt;connection_id\\\u0026gt; my_thread_id m_thread_id; }; // Used to generate the \u0026#34;query\u0026#34; field in JSON explain object. void print_query_for_explain(const THD *query_thd, Query_expression *unit, String *str); #endif /* OPT_EXPLAIN_INCLUDED */ 这里实现源码过多，感兴趣自行阅读。\nstatistic 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 struct TABLE; typedef float rec_per_key_t; class KEY; /** 这里内容较少且命名清晰，直接参考原文 Guesstimate for \u0026#34;records per key\u0026#34; when index statistics is not available. @param table the table @param key the index @param used_keyparts the number of key part that should be included in the estimate @return estimated records per key value */ rec_per_key_t guess_rec_per_key(const TABLE *const table, const KEY *const key, uint used_keyparts); #endif /* OPT_STATISTICS_INCLUDED */ // 实现：opt_statistic.cc rec_per_key_t guess_rec_per_key(const TABLE *const table, const KEY *const key, uint used_keyparts) { // 参数校验 assert(used_keyparts \u0026gt;= 1); assert(used_keyparts \u0026lt;= key-\u0026gt;actual_key_parts); assert(!key-\u0026gt;has_records_per_key(used_keyparts - 1)); // 从 table 对象中获取总记录数 const ha_rows table_rows = table-\u0026gt;file-\u0026gt;stats.records; /* 预估key匹配records： 如果统计信息中有key匹配的records记录就直接使用 没有的话唯一索引默认匹配一个，普通索引默认匹配10个 */ rec_per_key_t rec_per_key_all; if (key-\u0026gt;has_records_per_key(key-\u0026gt;user_defined_key_parts - 1)) rec_per_key_all = key-\u0026gt;records_per_key(key-\u0026gt;user_defined_key_parts - 1); else { if (key-\u0026gt;actual_flags \u0026amp; HA_NOSAME) rec_per_key_all = 1.0f; // Unique index else { rec_per_key_all = 10.0f; // Non-unique index /* 之前假设普通索引匹配10条，如果是很小的这里需要调整实际匹配量 */ rec_per_key_all = std::min(rec_per_key_all, max(rec_per_key_t(table_rows) / 10, 1.0f)); } } rec_per_key_t rec_per_key; // 假设第一个键部分匹配1%的记录，总体记录数的1%作为估算 const rec_per_key_t rec_per_key_first = table_rows * 0.01f; if (rec_per_key_first \u0026lt; rec_per_key_all) { // 第一部分的估算小于完整键的估算，直接使用完整键的估算。 rec_per_key = rec_per_key_all; } else { if (key-\u0026gt;user_defined_key_parts \u0026gt; 1) { // See formula above：随着使用的键部分数量的增加，记录的匹配数量将相应调整 rec_per_key = rec_per_key_first - (rec_per_key_t(used_keyparts - 1) / (key-\u0026gt;user_defined_key_parts - 1)) * (rec_per_key_first - rec_per_key_all); } else { // 对于单列索引，依据索引的唯一性直接返回相应的估算值。 if (key-\u0026gt;actual_flags \u0026amp; HA_NOSAME) rec_per_key = 1.0f; // Unique index else rec_per_key = rec_per_key_first; // Non-unique index } assert(rec_per_key \u0026gt;= rec_per_key_all); } return rec_per_key; } 其中存在部分外部函数：均来自于key.h\nhas_records_per_key records_per_key 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 // 内存中的索引数据结构 class KEY { public: /** Tot length of key */ uint key_length{0}; /** dupp key and pack flags */ ulong flags{0}; /** dupp key and pack flags for actual key parts */ ulong actual_flags{0}; /** How many key_parts */ uint user_defined_key_parts{0}; /** How many key_parts including hidden parts */ uint actual_key_parts{0}; /** Key parts allocated for primary key parts extension but not used due to some reasons(no primary key, duplicated key parts) */ uint unused_key_parts{0}; /** Should normally be = actual_key_parts */ uint usable_key_parts{0}; uint block_size{0}; /// @cond Doxygen_is_confused enum ha_key_alg algorithm { HA_KEY_ALG_SE_SPECIFIC }; /// @endcond /** A flag which indicates that index algorithm for this key was explicitly specified by user. So, for example, it should be mentioned in SHOW CREATE TABLE output. */ bool is_algorithm_explicit{false}; /** Note that parser is used when the table is opened for use, and parser_name is used when the table is being created. */ /** Fulltext [pre]parser */ plugin_ref parser{nullptr}; /** Fulltext [pre]parser name */ LEX_CSTRING parser_name{nullptr, 0}; KEY_PART_INFO *key_part{nullptr}; /** Name of key */ const char *name{nullptr}; /** Array of AVG(number of records with the same field value) for 1st ... Nth key part. 0 means \u0026#39;not known\u0026#39;. For internally created temporary tables, this member can be nullptr. */ ulong *rec_per_key{nullptr}; /** @retval true if this is a functional index (at least one of the key parts is a functional key part). @retval false if this isn\u0026#39;t a functional index. */ bool is_functional_index() const; // Can\u0026#39;t use in-class initialization as long as we memset-initialize // the struct LEX_CSTRING engine_attribute{nullptr, 0}; LEX_CSTRING secondary_engine_attribute{nullptr, 0}; private: /** Estimate for how much of the index data that is currently available in a memory buffer. Valid range is [0..1]. This will be initialized to a IN_MEMORY_ESTIMATE_UNKNOWN. If it still has this value when used, it means that the storage engine has not supplied a value. */ double m_in_memory_estimate{0.0}; /** 这里就是每一个索引匹配的records数量数据结构，通过指针存了一个float数组 Array of AVG(number of records with the same field value) for 1st ... Nth key part. For internally created temporary tables, this member can be nullptr. This is the same information as stored in the above rec_per_key array but using float values instead of integer values. If the storage engine has supplied values in this array, these will be used. Otherwise the value in rec_per_key will be used. @todo In the next release the rec_per_key array above should be removed and only this should be used. */ rec_per_key_t *rec_per_key_float{nullptr}; public: /** True if this index is visible to the query optimizer. The optimizer may only use visible indexes. */ bool is_visible{false}; TABLE *table{nullptr}; LEX_CSTRING comment{nullptr, 0}; /** Check if records per key estimate is available for given key part. @param key_part_no key part number, must be in [0, KEY::actual_key_parts) @return true if records per key estimate is available, false otherwise */ bool has_records_per_key(uint key_part_no) const { assert(key_part_no \u0026lt; actual_key_parts); return ((rec_per_key_float \u0026amp;\u0026amp; rec_per_key_float[key_part_no] != REC_PER_KEY_UNKNOWN) || (rec_per_key \u0026amp;\u0026amp; rec_per_key[key_part_no] != 0)); } /** Retrieve an estimate for the average number of records per distinct value, when looking only at the first key_part_no+1 columns. If no record per key estimate is available for this key part, REC_PER_KEY_UNKNOWN is returned. @param key_part_no key part number, must be in [0, KEY::actual_key_parts) @return Number of records having the same key value @retval REC_PER_KEY_UNKNOWN no records per key estimate available @retval != REC_PER_KEY_UNKNOWN record per key estimate */ rec_per_key_t records_per_key(uint key_part_no) const { assert(key_part_no \u0026lt; actual_key_parts); /* If the storage engine has provided rec per key estimates as float then use this. If not, use the integer version. */ if (rec_per_key_float[key_part_no] != REC_PER_KEY_UNKNOWN) return rec_per_key_float[key_part_no]; return (rec_per_key[key_part_no] != 0) ? static_cast\u0026lt;rec_per_key_t\u0026gt;(rec_per_key[key_part_no]) : REC_PER_KEY_UNKNOWN; } } 这里代码量较少，可以比较直观的理解mysql优化器统计索引效率的流程。\n存储引擎（索引） innoDB 事务支持 mvcc 行锁 redolog \u0026amp; undolog .ibd文件存索引+数据 InnoDB的文件结构可以划分为多个段（segment）、区（extent）、页（page）等层级。每个索引都存储在特定的段中，而每个段又由多个区组成，每个区包含多个页。在InnoDB中，页是磁盘和内存之间交换数据的最小单位，通常是16KB大小。 Feature Support B-tree indexes Yes Clustered indexes Yes Compressed data Yes Data caches Yes Foreign key support Yes Full-text search indexes Yes Geospatial data type support Yes Geospatial indexing support Yes Hash indexes No Index caches Yes Locking granularity Row MVCC Yes Storage limits 64TB T-tree indexes No Transactions Yes Update statistics for data dictionary Yes 架构 MyISAM 表锁 读多写少 .MYI文件存储索引信息，.MYD文件存储数据（查索引后需要回表） Feature Support B-tree indexes Yes Clustered indexes No Compressed data Yes (Compressed MyISAM tables are supported only when using the compressed row format. Tables using the compressed row format with MyISAM are read only.) Data caches No Foreign key support No Full-text search indexes Yes Geospatial data type support Yes Geospatial indexing support Yes Hash indexes No Index caches Yes Locking granularity Table MVCC No Storage limits 256TB T-tree indexes No Transactions No Update statistics for data dictionary Yes MEMORY 内存 hash Feature Support B-tree indexes Yes Clustered indexes No Compressed data No Data caches No Foreign key support No Full-text search indexes No Geospatial data type support No Geospatial indexing support No Hash indexes Yes Index caches No Locking granularity Table MVCC No Storage limits RAM T-tree indexes No Transactions No Update statistics for data dictionary Yes 其他存储引擎（略） CSV ARCHIVE MERGE 参考：\nhttps://dev.mysql.com/doc/refman/8.4/en/manual-info.html\nhttps://www.cnblogs.com/kerrycode/p/11821042.html\nhttps://github.com/mysql/mysql-server/tree/8.4/sql\n","date":"2024-09-15T00:58:29+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E6%A6%82%E8%A7%88/","title":"高性能MySql-概览"},{"content":"","date":"2024-09-15T00:56:01+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6-netty/","title":"高性能网络通信框架 Netty"},{"content":"","date":"2024-09-15T00:47:54+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8-reids-%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/","title":"高性能\u0026高可用 reids-分布式集群"},{"content":"","date":"2024-09-15T00:45:33+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD-reids-%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/","title":"高性能 reids-空间效率"},{"content":"","date":"2024-09-15T00:45:27+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD-reids-%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87/","title":"高性能 reids-时间效率"},{"content":"","date":"2024-09-15T00:44:33+08:00","permalink":"http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD-reids-%E9%80%9A%E4%BF%A1/","title":"高性能 reids-通信"},{"content":"数学基础： 高等数学：导数、微分、偏导数（多元函数导数）\n线性代数：向量、行列式、矩阵的基本运算、秩\n高等数学 导数 \\[ f'(x_0) = \\frac{dy}{dx} = \\lim_{x \\to x_0} \\frac{f(x) - f(x_0)}{x - x_0} \\]极限 ε δ 语言： 函数 $f(x)$ 在点 $x_0$ 的某一去心邻域内有定义。如果存在常数 $a$，对于任意的 $\\epsilon \u0026gt; 0$，都存在 $\\delta \u0026gt; 0$，使得在 $0 \u0026lt; |x - x_0| \u0026lt; \\delta$ 时，不等式 $|f(x) - a| \u0026lt; \\epsilon$ 恒成立。那么常数 $a$ 就叫做函数 $f(x)$ 当 $x \\to x_0$ 时的极限，记作： $$ \\lim_{x \\to x_0} f(x) = a $$微分 函数变化量 = 变化率 * 参数变化量 $$ df(x) = f'(x) \\, dx $$偏导 对于一个多元函数 $f(x_1, x_2, \\ldots, x_n)$，它在点 $(x_1^0, x_2^0, \\ldots, x_n^0)$ 处的偏导数相对于 $x_i$ 是： $$ \\frac{\\partial f}{\\partial x_i} = \\lim_{h \\to 0} \\frac{f(x_1^0, \\ldots, x_i^0 + h, \\ldots, x_n^0) - f(x_1^0, \\ldots, x_i^0, \\ldots, x_n^0)}{h} $$偏导的链式法则 假设我们有两个函数 $u = g(x_1, x_2, \\ldots, x_n)$ 和 $y = f(u)$，其中 $u$ 是 $x_1, x_2, \\ldots, x_n$ 的函数，而 $y$ 是 $u$ 的函数。我们希望找到 $y$ 对 $x_i$ 的偏导数。\n链式法则的定义是：\n$$ \\frac{\\partial y}{\\partial x_i} = \\frac{\\partial y}{\\partial u} \\cdot \\frac{\\partial u}{\\partial x_i} $$其中：\n$\\frac{\\partial y}{\\partial u}$ 是 $y$ 对 $u$ 的偏导数。 $\\frac{\\partial u}{\\partial x_i}$ 是 $u$ 对 $x_i$ 的偏导数。 证明 全微分关系为： $$ dz = \\frac{\\partial z}{\\partial u} \\, du + \\frac{\\partial z}{\\partial v} \\, dv $$由于 $u$ 和 $v$ 是 $x$ 和 $y$ 的函数，我们有： $$ du = \\frac{\\partial u}{\\partial x} \\, dx + \\frac{\\partial u}{\\partial y} \\, dy $$$$ dv = \\frac{\\partial v}{\\partial x} \\, dx + \\frac{\\partial v}{\\partial y} \\, dy $$将这些代入全微分公式中，得到： $$ dz = \\left( \\frac{\\partial z}{\\partial u} \\frac{\\partial u}{\\partial x} + \\frac{\\partial z}{\\partial v} \\frac{\\partial v}{\\partial x} \\right) dx + \\left( \\frac{\\partial z}{\\partial u} \\frac{\\partial u}{\\partial y} + \\frac{\\partial z}{\\partial v} \\frac{\\partial v}{\\partial y} \\right) dy $$链式法则的偏导数 根据全微分关系，链式法则的偏导数为： $$ \\frac{\\partial z}{\\partial x} = \\frac{\\partial z}{\\partial u} \\frac{\\partial u}{\\partial x} + \\frac{\\partial z}{\\partial v} \\frac{\\partial v}{\\partial x} $$$$ \\frac{\\partial z}{\\partial y} = \\frac{\\partial z}{\\partial u} \\frac{\\partial u}{\\partial y} + \\frac{\\partial z}{\\partial v} \\frac{\\partial v}{\\partial y} $$线性代数 向量的定义 向量是一个具有大小和方向的量，通常在多维空间中表示为一个有序的数列。一个 $n$ 维向量可以写作：\n$$ \\mathbf{v} = \\begin{bmatrix} v_1 \\\\ v_2 \\\\ \\vdots \\\\ v_n \\end{bmatrix} $$行列式的定义 行列式是一个方阵的一个标量值，它可以用来描述矩阵的某些性质，比如可逆性。对于一个 $n \\times n$ 的方阵 $A$，行列式记作 $\\det(A)$ 或 $|A|$，可以表示为：\n对于 $2 \\times 2$ 矩阵：\n$$ \\det \\begin{pmatrix} a \u0026 b \\\\ c \u0026 d \\end{pmatrix} = ad - bc $$对于 $3 \\times 3$ 矩阵：\n$$ \\det \\begin{pmatrix} a \u0026 b \u0026 c \\\\ d \u0026 e \u0026 f \\\\ g \u0026 h \u0026 i \\end{pmatrix} = aei + bfg + cdh - ceg - bdi - afh $$矩阵的定义 矩阵是一个按照矩形阵列排列的数值集合。一个 $m \\times n$ 的矩阵可以表示为：\n$$ A = \\begin{bmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\end{bmatrix} $$矩阵的基本运算 1. 矩阵加法 两个同型矩阵 $A$ 和 $B$ 的加法是元素对应相加，得到的新矩阵为： 如果 $$ A = \\begin{bmatrix} a_{11} \u0026 a_{12} \\\\ a_{21} \u0026 a_{22} \\end{bmatrix} $$$$ B = \\begin{bmatrix} b_{11} \u0026 b_{12} \\\\ b_{21} \u0026 b_{22} \\end{bmatrix} $$ 那么 $$ A + B = \\begin{bmatrix} a_{11} + b_{11} \u0026 a_{12} + b_{12} \\\\ a_{21} + b_{21} \u0026 a_{22} + b_{22} \\end{bmatrix} $$2. 矩阵减法 两个同型矩阵 $A$ 和 $B$ 的减法是元素对应相减，得到的新矩阵为： $$ A - B = \\begin{bmatrix} a_{11} - b_{11} \u0026 a_{12} - b_{12} \\\\ a_{21} - b_{21} \u0026 a_{22} - b_{22} \\end{bmatrix} $$3. 矩阵数乘 矩阵 $A$ 与标量 $k$ 的数乘是矩阵中每个元素都乘以 $k$，得到的新矩阵为： 如果 $$ A = \\begin{bmatrix} a_{11} \u0026 a_{12} \\\\ a_{21} \u0026 a_{22} \\end{bmatrix} $$ 那么 $$ kA = \\begin{bmatrix} ka_{11} \u0026 ka_{12} \\\\ ka_{21} \u0026 ka_{22} \\end{bmatrix} $$4. 矩阵乘法 两个矩阵 $A$ 和 $B$ 的乘法是矩阵 $A$ 的行向量与矩阵 $B$ 的列向量的内积，得到的新矩阵 $C$ 为： 如果 $$ A = \\begin{bmatrix} a_{11} \u0026 a_{12} \\\\ a_{21} \u0026 a_{22} \\end{bmatrix} $$$$ B = \\begin{bmatrix} b_{11} \u0026 b_{12} \\\\ b_{21} \u0026 b_{22} \\end{bmatrix} $$ 那么 $$ C = AB = \\begin{bmatrix} a_{11}b_{11} + a_{12}b_{21} \u0026 a_{11}b_{12} + a_{12}b_{22} \\\\ a_{21}b_{11} + a_{22}b_{21} \u0026 a_{21}b_{12} + a_{22}b_{22} \\end{bmatrix} $$5. 矩阵转置 矩阵 $A$ 的转置是将矩阵 $A$ 的行和列互换得到的新矩阵 $A^T$： 如果 $$ A = \\begin{bmatrix} a_{11} \u0026 a_{12} \\\\ a_{21} \u0026 a_{22} \\end{bmatrix} $$ 那么 $$ A^T = \\begin{bmatrix} a_{11} \u0026 a_{21} \\\\ a_{12} \u0026 a_{22} \\end{bmatrix} $$6. 矩阵的逆 矩阵 $A$ 的逆矩阵 $A^{-1}$ 是使得 $AA^{-1} = A^{-1}A = I$ 的矩阵，其中 $I$ 是单位矩阵。对于 $2 \\times 2$ 矩阵 $A$，如果行列式 $\\det(A) \\neq 0$，其逆矩阵为： 如果 $$ A = \\begin{bmatrix} a \u0026 b \\\\ c \u0026 d \\end{bmatrix} $$ 那么 $$ A^{-1} = \\frac{1}{\\det(A)} \\begin{bmatrix} d \u0026 -b \\\\ -c \u0026 a \\end{bmatrix} $$ 其中行列式 $\\det(A)$ 为： $$ \\det(A) = ad - bc $$7. 矩阵的秩 矩阵的秩（rank）是矩阵中线性无关的行（或列）的最大数量。矩阵的秩可以用来判断矩阵的行或列的线性独立性。\n对于一个 $m \\times n$ 的矩阵 $A$，秩定义为：\n矩阵 $A$ 的行秩：矩阵 $A$ 的最大线性无关的行的数量。 矩阵 $A$ 的列秩：矩阵 $A$ 的最大线性无关的列的数量。 行秩和列秩总是相等，这个公共值称为矩阵的秩，记作 $\\text{rank}(A)$。\n举例 假设有一个矩阵 $A$：\n$$ A = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{bmatrix} $$矩阵 $A$ 的秩是 $2$，因为矩阵的行或列中最大数量的线性无关的行或列是 $2$。\n步骤 r2 = r2 - 4*r1\nr3 = r3 - 7*r1\nr2 = -1/3*r2\nr3 = r3 + 6*r2\n机器学习基本概念 ml类别 监督学习 有数据标注的机器学习\n分类问题 给出X样本，以及样本中每一行对应的标注结果集Y\n根据样本特征，预测新样本的结果\n回归问题 给出X样本，以及样本中每一行对应的标注结果集Y\n根据样本特征，预测新样本的趋势\n无监督学习 无数据标注的机器学习\n聚类问题 仅给出X样本\n通过算法划分出不同的类别。\n注： 大多数机器学习应用多属于监督学习，后续仅对knn聚类算法做了简单介绍，其他算法均为监督学习。\n","date":"2024-09-14T02:06:14+08:00","permalink":"http://localhost:1313/zh-cn/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","title":"神经网络"},{"content":"计算机网络 本文主要参考了谢希仁老师编著的《计算机网络》教材第七版，并且后续会更新本书的全部章节，帮助每个程序员新人来理解相关的概念。\n文章中包含了许多体系化的知识以及相关的发展历史，个人认为据因寻果是一种非常有助于理解学习的内容，激发学习的兴趣的一种学习方法。希望能给各位同学们带来些许帮助。\n网络概述 80后出生的许多人都被认为是生活在网络的时代，但其实，早在电报被广泛使用的二十世纪初，网络便渗透进了每个人的日常生活中。通信网络，使得每个人接收信息更加快速与便捷，直到计算机网络被广泛使用的现在，信息的透明度以及便捷度相较于非信息时代的时间里不可同日而语，现如今，某个明星早上出的八卦内容，在当天就能给某些企业的服务器带来巨大的流量压力；信息的快速传播也给此次的新型流感防疫工作带来了明显的帮助。如果你是相关专业的同学，阅读这篇文章能给你带来对网络的进一步理解，而非相关专业的同学也能收获一些通用的信息知识。\n网络的分类 电信网络 有线电视网络 计算机网络 网络类型 主要应用 应用抽象 电信网络 电报，电话，传真 音频内容 有线电视网络 电视 视频内容 计算机网络 计算机（电脑） 多媒体内容，数据文件 理论上来讲，三种网络融合成一种带宽足够大的网络即可提供所有服务，但出于对经济以及行政方面的考量，这样的设想还是很难推进。不过在应用层面，已经有许多计算机（包含pc，手机等个人计算机设备）软件已经提供了基于计算机网络的视频或通信功能。\n网络的性质 连通性 使用网络的两端用户之间，无论距离远近均能非常便捷，经济地交换各种信息，好像用户终端都彼此连通一般，故称其为连通性。\n共享性 网络上的资源能够共享，并且网络上公开的资源就好像在用户身边一样便于使用。\n网络的这两种性质，基本概述了网络的基本功能：数据传输。 不过网络对于数据传输的方法，却经历了大概3个时期：\n电路交换：整个报文的比特流连续的从源点直达终点。 这是一种非常”古老“的数据传输方式，通常用于电信网络（电报电话）。 它的工作流程大致如下： 建立连接\u0026ndash;\u0026gt;通信\u0026ndash;\u0026gt;释放连接 在整个通信期间，两个用户始终占用端到端的通信资源，这样虽然信息流传输速率比较快，但是将会导致通信成本非常高昂以及通信资源的大量浪费。\n报文交换：整个报文先传送到相邻节点，全部存储完成后查找转发表，转发到下一个节点，依次类推直到到达通信终点。 这种传输方式解决了用户对端到端通信资源的持续占用，不过每次转发需要存储整个报文，必然会导致传输速率非常慢，延迟非常高，因此这是一种较不成熟的过渡传输方法。\n分组交换：报文分组后将单个分组传输到相邻节点，存储下来后查找转发表，转发到下一个节点，依次类推直到到达通信终点。 在报文交换的基础上进行了分组，每次转发只需要存储一边单一分组即可，不同的划分也会影响到其传输性能，不过在研究者们的刻苦攻坚下，这个问题基本以及被解决，优秀的分组计划可以加快数据的传输，虽然速率可能比不过电路交换那种连续点到点的通信，不过通信资源占用量低，可以大大降低通信成本，让每个人都有参与网络使用的机会，加速网络的普及。\n网络性能主要指标 速率 单位：bps，bit per second，比特每秒 带宽（易混淆） 带宽分为时域带宽与频域带宽 频域带宽：电子信号所占据的频带宽度，单位Hz 时域带宽：即最高速率，单位与速率相同，bps 我们现实生活中讨论的带宽通常是指时域带宽，例如你在电信公司办理了一个100M光前宽带，这里的100M就是100Mbps，换算为字节后要除以8（1Byte=8bit），也就成为了你下载的下行速率12.5MB/s。\n而频域带宽，这里以5G移动网络信号为例： 频域带宽就是电子信号所占据的频带宽度，不同的频域带宽，根据频率波长的关系，它的性能也往往有所差异，因此，有限的优秀频段往往成为一种竞争化的资源。这里再以5G移动网络信号为例： 这里不难看出，各国的频域带宽都是不同的，以避免信号之间的相互干扰，不过具体的频段优劣，涉及到国与国之间的内容，这里不做详述。\n3.吞吐量（易混淆） 吞吐量表示的是单位时间内实际传输的信号数量，因此，单位又是bps（惊不惊喜意不意外）。 这里着重强调的是实际传输，因此这个参数也是一个能比较真实的反应你所使用的网络的性能的指标，它也往往会低于电信运营商所标识的额定时域带宽。\n计算机网络（互联网）概述 上面的内容还是对于所有网络这个宏观的概念进行讲解，下面进入计算机网络（后文简称计网）的概述内容。\n在RFC[1208]中，规定了互联网（Internet）与互连网（internet）属于不同的概念，简单地说，互连网包含了互联网（实际中两者基本通用）。\n计网的组成 计算机网络（网络）由若干个结点（非节点）和连接这些结点的链路所组成。\n这里结点与节点的区分，个人理解为结点可以包含多个节点 结点可以是由一个个微型的私人局域网，路由器，交换机等用以提供网络服务的host所构成\n这里所有接入互联网，由用户直接使用的主机被称为：互联网的边缘部分 大量网络和连接它们的路由器等为互联网的边缘部分提供服务的设施被称为：互联网的核心部分\n计算机网络的组成部分中，最为核心的部件是路由器，它是实现分组交换的关键构件，任务是转发所有被其收到的数据包分组。\n计网的通信架构 C/S，client and server 这里的client主要是向互联网申请各种服务的用户； server是在互联网范围内给用户提供实际服务的企业或个人。 互联网的绝大多数应用都是基于此架构。\nP2P，peer to peer，也可以理解为person to person 这里的每台主机既是客户端，又是服务端，相较于C/S架构使用量较少 最典型的应用就是P2P下载应用，每台主机都可以作为内容的暂存者，当你需要下载某些数据时，可以优先找到能提供更快速率下载的peer直接下载，不需要每次都访问官方的server，极大的加快下载速率。\n计网的发展 一、 单个网络ARPANET向互联网发展（实验阶段：1969-1990） 高级研究计划局网络（英语：Advanced Research Projects Agency Network），通称阿帕网（英语：ARPANET）是美国国防高级研究计划局开发的世界上第一个运营的数据包交换网络，是全球互联网的鼻祖。\n最初，arpanet只是一个单个的分组交换网，并非是一个互连的网络，随着时间的发展，通信需求的增加带来了许多通信协议的诞生，这些通信协议又有利于更高级的协议编写，慢慢地，由TCP/IP协议族（20世纪80年代，有心的同学可以结合计算机在这个时期的发展来进行更深度的思考）为主导的互联网开始显露出来。 \u0026ndash;wiki百科\n二、三级结构的互联网雏形（科研阶段：21世纪初期） 主干网络-\u0026gt;地区网络-\u0026gt;校园/企业网络\n三、多层次ISP结构的互联网（实用阶段：现在） 名词解释ISP：Internet Service Provider，互联网服务提供商，也就是我们国家的电信运营商（电信，移动等），基本上所有的网络服务（主干网）都是由他们建造并提供相应的服务。\n主干ISP-\u0026gt;地区ISP-\u0026gt;企业网络/本地ISP-\u0026gt;个人网络\n计网的标准化工作流程 组织：IETF，互联网工程部；IETF，互联网研究部\n三大阶段（由先到后） 互联网草案（每个草案大约保存6个月） 互联网建议标准（录入至RFC文档） 互联网标准（多个RFC文档的关联） 计网体系结构（重点） 仅仅有物理通路用以传输数据对于计算机之间还远远不够，面对计算机之间的通信，还需要处理以下几个问题：\n激活物理通路 识别接收对象 检测网络连接正常 审核准备工作 数据格式转换 出错备案 ARPANET提出了”分层”的方法，这些问题在后面的各个网络协议中被分别解决。\n网络协议 osi七层网络模型中，每一层的实现都有相对应的网络协议。 包含但不限于：ARP，RARP，IPv4/v6，TCP，HTTP，FTP，SMTP，SSL等协议 这些协议通常扮演者一个统一化的角色，因此我们需要了解网络协议的相关概念。\n定义 为进行网络中的数据交换而建立的规则，标准，或约定被称为网络协议。（==》这些内容规定了传输的数据格式及有关的同步问题。）\n三要素 语法：数据与控制信息的结构或格式 语义：控制及响应信息 同步：事件实现的详细说明 另：单机程序可以不需要任何网络协议的参与，例如一个简单的hello world程序。\n网络模型 tcp/ip模型 这是使用最为广泛的一个网络模型\nosi七层模型 这是最官方的一个网络模型\ntcp/ip五层网络模型 这是一个折中的网络模型\ntcp/ip模型中的网络接口被拆分为物理层与数据链路层。\n网络模型中的数据传输内容（以osi模型为例） 除物理层中传输的为比特流以外，其他各层都以数据包的形式来传输数据（数据包~=数据头部header+数据内容）。\n数据头部在每个网络协议中都有不同的规定，根据这些规定加上相关的算法，就可以解决上文提到的，计算机网络传输数据还需要处理的几个问题。\n激活物理通路 识别接收对象 检测网络连接正常 审核准备工作 数据格式转换 出错备案 ","date":"2022-03-06T00:00:00Z","image":"http://localhost:1313/zh-cn/p/hello-world/cover_hu6307248181568134095.jpg","permalink":"http://localhost:1313/zh-cn/p/hello-world/","title":"计算机网络基本发展"},{"content":"","date":"2024-09-15T01:23:56+08:00","permalink":"http://localhost:1313/zh-cn/p/%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1-%E9%89%B4%E6%9D%83%E6%8E%88%E6%9D%83/","title":"权限设计-鉴权授权"},{"content":"","date":"2024-09-15T01:12:40+08:00","permalink":"http://localhost:1313/zh-cn/p/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-orm-spring/","title":"开发框架-orm-spring"},{"content":"","date":"2024-09-15T01:11:15+08:00","permalink":"http://localhost:1313/zh-cn/p/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-aop-spring/","title":"开发框架-aop-spring"},{"content":"","date":"2024-09-15T01:11:09+08:00","permalink":"http://localhost:1313/zh-cn/p/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-ioc-spring/","title":"开发框架-ioc-spring"},{"content":"","date":"2024-09-15T01:10:50+08:00","permalink":"http://localhost:1313/zh-cn/p/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-%E6%A6%82%E8%A7%88-spring/","title":"开发框架-概览-spring"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rDiff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"http://localhost:1313/zh-cn/p/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","title":"Markdown基本语法"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"http://localhost:1313/zh-cn/p/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD-%E5%B1%95%E7%A4%BA/2_hu15576070775610481867.jpg","permalink":"http://localhost:1313/zh-cn/p/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD-%E5%B1%95%E7%A4%BA/","title":"图片加载 \u0026 展示"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"http://localhost:1313/zh-cn/p/%E5%A4%96%E9%93%BE%E4%BD%BF%E7%94%A8/cover_hu17063188895770243625.jpg","permalink":"http://localhost:1313/zh-cn/p/%E5%A4%96%E9%93%BE%E4%BD%BF%E7%94%A8/","title":"外链使用"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$\r\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r$$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/zh-cn/p/%E6%95%B0%E5%AD%A6%E6%94%AF%E6%8C%81-latex/","title":"数学支持-latex"}]