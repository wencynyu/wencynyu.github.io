<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="redis通信 源码分析 系统初始化 &amp; eventloop事件循环总线构建 从main函数说起（原300+行，精简部分非核心内容后包含注释100+行） 网络通信相关主要为：在main函数中启动epoll监听，io多路复用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 int main(int argc, char **argv) { struct timeval tv; int j; char config_from_stdin = 0; /* 系统基础依赖初始化： 1. 时区设置 2. 内存oom处理方法 3. 随机数/哈希种子生成 4. crc64校验码初始化 */ char *exec_name = strrchr(argv[0], &#39;/&#39;); if (exec_name == NULL) exec_name = argv[0]; server.sentinel_mode = checkForSentinelMode(argc,argv, exec_name); initServerConfig(); ACLInit(); /* 初始化 ACL（访问控制列表）系统，网络连接时需要根据ACL控制权限，此时未加载实际配置 */ moduleInitModulesSystem(); connTypeInitialize(); /* 存储可执行文件路径和启动参数，用于以后重启服务器 */ server.executable = getAbsolutePath(argv[0]); server.exec_argv = zmalloc(sizeof(char*)*(argc+1)); server.exec_argv[argc] = NULL; for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]); /* 初始化 Sentinel 相关配置（如果是 Sentinel 模式） */ if (server.sentinel_mode) { initSentinelConfig(); initSentinel(); } /* 检查是否需要启动 redis-check-rdb 或 redis-check-aof 模式 */ if (strstr(exec_name,&#34;redis-check-rdb&#34;) != NULL) redis_check_rdb_main(argc,argv,NULL); else if (strstr(exec_name,&#34;redis-check-aof&#34;) != NULL) redis_check_aof_main(argc,argv); /* 参数解析 */ if (argc &gt;= 2) { j = 1; sds options = sdsempty(); // 使用内部定义的sds字符串结构 /* 解析特殊参数 --version，--help */ if (strcmp(argv[1], &#34;-v&#34;) == 0 || strcmp(argv[1], &#34;--version&#34;) == 0) { sds version = getVersion(); printf(&#34;Redis server %s\\n&#34;, version); sdsfree(version); exit(0); } if (strcmp(argv[1], &#34;--help&#34;) == 0 || strcmp(argv[1], &#34;-h&#34;) == 0) usage(); sds *argv_tmp; int argc_tmp; int handled_last_config_arg = 1; while(j &lt; argc) { /* 遍历解析参数 */ j++; } /* 根据参数完成必要文件配置的加载 */ loadServerConfig(server.configfile, config_from_stdin, options); if (server.sentinel_mode) loadSentinelConfigFromQueue(); sdsfree(options); } if (server.sentinel_mode) sentinelCheckConfigFile(); /* 核心：启动服务 */ initServer(); // 核心中的核心：载入server对象相关的核心组件：signal信号处理器，thread线程管理器，eventloop事件处理总线等 if (background || server.pidfile) createPidFile(); if (server.set_proc_title) redisSetProcTitle(NULL); redisAsciiArt(); // 打印启动redis的ASCII文字 checkTcpBacklogSettings(); if (server.cluster_enabled) { clusterInit(); } if (!server.sentinel_mode) { moduleInitModulesSystemLast(); moduleLoadFromQueue(); } // acl读取实际配置 ACLLoadUsersAtStartup(); initListeners(); if (server.cluster_enabled) { clusterInitLast(); } InitServerLast(); if (!server.sentinel_mode) { // 非sentinel模式 serverLog(LL_NOTICE,&#34;Server initialized&#34;); aofLoadManifestFromDisk(); loadDataFromDisk(); aofOpenIfNeededOnServerStart(); aofDelHistoryFiles(); applyAppendOnlyConfig(); // 集群模式校验 if (server.cluster_enabled) { serverAssert(verifyClusterConfigWithData() == C_OK); } // 打印所有监听器的状态 for (j = 0; j &lt; CONN_TYPE_MAX; j++) { connListener *listener = &amp;server.listeners[j]; if (listener-&gt;ct == NULL) continue; serverLog(LL_NOTICE,&#34;Ready to accept connections %s&#34;, listener-&gt;ct-&gt;get_type(NULL)); } if (server.supervised_mode == SUPERVISED_SYSTEMD) { // 如果是由 systemd 监督运行的 Redis 实例，通知 systemd Redis 状态 } } else { sentinelIsRunning(); if (server.supervised_mode == SUPERVISED_SYSTEMD) { // 如果是由 systemd 监督运行的 sentinel 实例，通知 systemd sentinel 状态 } } /* 内存分配过小（1MB）警告 */ if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) { serverLog(LL_WARNING,&#34;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&#34;, server.maxmemory); } redisSetCpuAffinity(server.server_cpulist); setOOMScoreAdj(-1); // epoll监听，io多路复用，死循环 aeMain(server.el); aeDeleteEventLoop(server.el); return 0; } 核心中的核心：initServer方法，载入server对象相关的核心组件：signal信号处理器，thread线程管理器，eventloop事件处理总线等。（原200+行，精简部分非核心内容后包含注释60+行） 网络通信相关主要为：在初始化函数中创建thread线程管理器，eventloop事件处理总线 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 void initServer(void) { // 信号处理器，例如ctrl+c发送SIGKILL信号，此时需要关闭服务 setupSignalHandlers(); // 线程管理器初始化 ThreadsManager_init(); makeThreadKillable(); /* 在从配置系统设置默认值后进行初始化 */ server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF; server.fsynced_reploff = server.aof_enabled ? 0 : -1; server.hz = server.config_hz; // 心跳频率 server.pid = getpid(); // 创建eventloop事件处理总线，基于epoll机制（linux） server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR); if (server.el == NULL) { serverLog(LL_WARNING, &#34;Failed creating the event loop. Error message: &#39;%s&#39;&#34;, strerror(errno)); exit(1); } /* 创建定时器回调，这是我们处理许多后台操作的方式， 比如客户端超时、未访问的过期键的淘汰等 */ if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) { serverPanic(&#34;Can&#39;t create event loop timers.&#34;); exit(1); } /* 为用于唤醒事件循环的管道注册一个可读事件， 用于模块线程间的通信 */ if (aeCreateFileEvent(server.el, server.module_pipe[0], AE_READABLE, modulePipeReadable,NULL) == AE_ERR) { serverPanic( &#34;Error registering the readable event for the module pipe.&#34;); } /* 注册epoll阻塞前后的回调函数（需在加载持久化之前完成，因为它会被 processEventsWhileBlocked 使用） */ aeSetBeforeSleepProc(server.el,beforeSleep); aeSetAfterSleepProc(server.el,afterSleep); /* 32位老系统受限于寻址上限32bit，最多访问2^32个字节，也就是4294967296B -&gt; 4GB，redis会默认限制3GB上限 */ if (server.arch_bits == 32 &amp;&amp; server.maxmemory == 0) { serverLog(LL_WARNING,&#34;Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with &#39;noeviction&#39; policy now.&#34;); server.maxmemory = 3072LL*(1024*1024); /* 3 GB */ server.maxmemory_policy = MAXMEMORY_NO_EVICTION; } // 脚本系统初始化 luaEnvInit(); scriptingInit(1); if (functionsInit() == C_ERR) { serverPanic(&#34;Functions initialization failed, check the server logs.&#34;); exit(1); } // 基本监控初始化：提供慢查询告警/延迟监控等功能 slowlogInit(); latencyMonitorInit(); // 参照配置初始化密码，一般不启用 ACLUpdateDefaultUserPassword(server.requirepass); // 定时器功能初始化 applyWatchdogPeriod(); if (server.maxmemory_clients != 0) initServerClientMemUsageBuckets(); } aeCreateEventLoop方法：创建事件循环总线 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 aeEventLoop *aeCreateEventLoop(int setsize) { aeEventLoop *eventLoop; monotonicInit(); /* just in case the calling app didn&#39;t initialize */ // 分配内存：最大感兴趣的fd为setsize if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err; eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize); eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize); if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err; eventLoop-&gt;setsize = setsize; eventLoop-&gt;timeEventHead = NULL; eventLoop-&gt;timeEventNextId = 0; eventLoop-&gt;stop = 0; eventLoop-&gt;maxfd = -1; eventLoop-&gt;beforesleep = NULL; eventLoop-&gt;aftersleep = NULL; eventLoop-&gt;flags = 0; if (aeApiCreate(eventLoop) == -1) goto err; // 核心：调用封装的函数aeApiCreate /* Events的关注事件默认置为0（不关注任何事件）*/ for (int i = 0; i &lt; setsize; i++) eventLoop-&gt;events[i].mask = AE_NONE; return eventLoop; err: // 失败则释放内存 if (eventLoop) { zfree(eventLoop-&gt;events); zfree(eventLoop-&gt;fired); zfree(eventLoop); } return NULL; } /* ae_epoll.c，仅在上面代码中调用，创建事件总线\t这里依赖系统内置库函数：epoll_create，其中size参数仅为参考值，对较新的linux版本来说无实际作用 */ static int aeApiCreate(aeEventLoop *eventLoop) { aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize); if (!state-&gt;events) { zfree(state); return -1; } state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */ if (state-&gt;epfd == -1) { zfree(state-&gt;events); zfree(state); return -1; } anetCloexec(state-&gt;epfd); eventLoop-&gt;apidata = state; return 0; } ae_epoll.c封装系统库函数（无精简） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 #include &lt;sys/epoll.h&gt; typedef struct aeApiState { int epfd; struct epoll_event *events; } aeApiState; /* 仅在aeCreateEventLoop代码中调用，创建事件总线\t依赖系统内置库函数：epoll_create，其中： size参数仅为参考值，对较新的linux版本来说无实际作用 */ static int aeApiCreate(aeEventLoop *eventLoop) { aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize); if (!state-&gt;events) { zfree(state); return -1; } state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */ if (state-&gt;epfd == -1) { zfree(state-&gt;events); zfree(state); return -1; } anetCloexec(state-&gt;epfd); eventLoop-&gt;apidata = state; return 0; } // resize event数组，类似vector(c)/list(java)/slice(golang/python)动态扩容 static int aeApiResize(aeEventLoop *eventLoop, int setsize) { aeApiState *state = eventLoop-&gt;apidata; state-&gt;events = zrealloc(state-&gt;events, sizeof(struct epoll_event)*setsize); return 0; } // 释放资源 static void aeApiFree(aeEventLoop *eventLoop) { aeApiState *state = eventLoop-&gt;apidata; close(state-&gt;epfd); zfree(state-&gt;events); zfree(state); } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_ctl，其中： epfd为事件总线fd， op为注册操作，枚举EPOLL_CTL_ADD, EPOLL_CTL_ADD, EPOLL_CTL_DEL， fd为注册的新fd， ee为新建的epoll_event结构体实例 */ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) { aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee = {0}; /* avoid valgrind warning */ /* If the fd was already monitored for some event, we need a MOD * operation. Otherwise we need an ADD operation. */ int op = eventLoop-&gt;events[fd].mask == AE_NONE ? EPOLL_CTL_ADD : EPOLL_CTL_MOD; ee.events = 0; mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */ if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.fd = fd; if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1; return 0; } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_ctl，其中： epfd为事件总线fd， op为注册操作，枚举EPOLL_CTL_ADD, EPOLL_CTL_ADD, EPOLL_CTL_DEL， fd为注册的新fd， ee为新建的epoll_event结构体实例，关注的mask写在这个结构体中 */ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) { aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee = {0}; /* avoid valgrind warning */ int mask = eventLoop-&gt;events[fd].mask &amp; (~delmask); ee.events = 0; if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.fd = fd; if (mask != AE_NONE) { epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee); } else { /* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for * EPOLL_CTL_DEL. */ epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee); } } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_wait，其中： epfd为事件总线fd， events为已注册的全部感兴趣事件， tvp相关为等待时间，-1为一直阻塞，直到有注册的感兴趣事件发生 */ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) { aeApiState *state = eventLoop-&gt;apidata; int retval, numevents = 0; retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize, tvp ? (tvp-&gt;tv_sec*1000 + (tvp-&gt;tv_usec + 999)/1000) : -1); if (retval &gt; 0) { int j; numevents = retval; for (j = 0; j &lt; numevents; j++) { int mask = 0; struct epoll_event *e = state-&gt;events+j; if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE; if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE; if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE|AE_READABLE; if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE; eventLoop-&gt;fired[j].fd = e-&gt;data.fd; eventLoop-&gt;fired[j].mask = mask; } } else if (retval == -1 &amp;&amp; errno != EINTR) { panic(&#34;aeApiPoll: epoll_wait, %s&#34;, strerror(errno)); } return numevents; } static char *aeApiName(void) { return &#34;epoll&#34;; } 哪些地方调用了注册事件 server启动过程中：initListeners -&gt; createSocketAcceptHandler （accept） connSocketAcceptHandler 创建客户端连接时：ConnectionType -&gt; connSocketConnect（connect） ae_handler -&gt; connSocketSetReadHandler 建立client通信时：createClient -&gt; readQueryFromClient ae_handler -&gt; connSocketSetWriteHandler 初始化服务端时：initServer -&gt; aeSetBeforeSleepProc -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads -&gt; sendReplyToClient 同步rdb数据：initServer -&gt; aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) -&gt; serverCron -&gt; checkChildrenDone -&gt; replicationStartPendingFork -&gt; rdbSaveToSlavesSockets rdbPipeReadHandler sentinel通信：initServer -&gt; aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) -&gt; serverCron -&gt; sentinelTimer -&gt; sentinelHandleDictOfRedisInstances -&gt; sentinelHandleRedisInstance -&gt; sentinelReconnectInstance -&gt; redisAeAttach -&gt; redisAeAddWrite pipeline管道的bio通信：initServer -&gt; InitServerLast -&gt; bioInit 注册事件处理：main -&gt; aeMain -&gt; aeApiPoll -&gt; epoll_wait 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 // 死循环处理事件 void aeMain(aeEventLoop *eventLoop) { eventLoop-&gt;stop = 0; while (!eventLoop-&gt;stop) { aeProcessEvents(eventLoop, AE_ALL_EVENTS| AE_CALL_BEFORE_SLEEP| AE_CALL_AFTER_SLEEP); } } typedef struct aeEventLoop { int maxfd; /* highest file descriptor currently registered */ int setsize; /* max number of file descriptors tracked */ long long timeEventNextId; aeFileEvent *events; /* Registered events */ aeFiredEvent *fired; /* Fired events */ aeTimeEvent *timeEventHead; int stop; void *apidata; /* This is used for polling API specific data */ aeBeforeSleepProc *beforesleep; aeBeforeSleepProc *aftersleep; int flags; } aeEventLoop; typedef struct aeFileEvent { int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */ aeFileProc *rfileProc; aeFileProc *wfileProc; void *clientData; } aeFileEvent; int aeProcessEvents(aeEventLoop *eventLoop, int flags) { int processed = 0, numevents; /* 如果没有文件事件和时间事件需要处理，直接返回 */ if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0; /* 即使没有文件事件，如果有时间事件，也需要调用 aeApiPoll 来等待下一次时间事件的触发 */ if (eventLoop-&gt;maxfd != -1 || ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) { int j; struct timeval tv, *tvp = NULL; /* NULL means infinite wait. */ int64_t usUntilTimer; if (eventLoop-&gt;beforesleep != NULL &amp;&amp; (flags &amp; AE_CALL_BEFORE_SLEEP)) /* Before sleep callback. */ eventLoop-&gt;beforesleep(eventLoop); /* eventLoop-&gt;flags 可能会在 beforeSleep 中发生改变，所以需要在调用 beforeSleep 后重新检查 同时，flags 参数优先级更高，特别是 AE_DONT_WAIT 设置时，应忽略 eventLoop-&gt;flags 中的值 */ if ((flags &amp; AE_DONT_WAIT) || (eventLoop-&gt;flags &amp; AE_DONT_WAIT)) { tv.tv_sec = tv.tv_usec = 0; tvp = &amp;tv; } else if (flags &amp; AE_TIME_EVENTS) { usUntilTimer = usUntilEarliestTimer(eventLoop); if (usUntilTimer &gt;= 0) { tv.tv_sec = usUntilTimer / 1000000; tv.tv_usec = usUntilTimer % 1000000; tvp = &amp;tv; } } /* 调用aeApiPoll多路复用方法，Call the multiplexing API, will return only on timeout or when some event fires. */ numevents = aeApiPoll(eventLoop, tvp); /* 如果没有请求处理文件事件，就跳过文件事件的处理 */ if (!(flags &amp; AE_FILE_EVENTS)) { numevents = 0; } /* After sleep callback. */ if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP) eventLoop-&gt;aftersleep(eventLoop); for (j = 0; j &lt; numevents; j++) { int fd = eventLoop-&gt;fired[j].fd; aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; int mask = eventLoop-&gt;fired[j].mask; int fired = 0; /* Number of events fired for current fd. */ /* 默认情况下，先执行可读事件，再执行可写事件。这个顺序可以确保有可读数据时，优先处理读取请求。 * 如果设置了 AE_BARRIER 标志，则表示我们希望反转执行顺序，先执行可写事件。 */ int invert = fe-&gt;mask &amp; AE_BARRIER; /* 检查事件是否仍然有效：可能已经处理过的事件在当前回合中已经被移除 */ if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) { fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */ } /* 执行可写事件 */ if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) { if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) { fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; } } /* 如果需要反转执行顺序，在可写事件后执行可读事件 */ if (invert) { fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */ if ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp; (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) { fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; } } processed++; } } /* 如果需要处理时间事件，则继续处理时间事件 */ if (flags &amp; AE_TIME_EVENTS) processed += processTimeEvents(eventLoop); return processed; } 多路复用处理方法（类似netty中的handler实现） 协议解析：createClient -&gt; readQueryFromClient -&gt; processInputBuffer -&gt; processXXXBuffer -&gt; processCommandAndResetClient inline：processInlineBuffer multi：processMultibulkBuffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 void readQueryFromClient(connection *conn) { client *c = connGetPrivateData(conn); int nread, big_arg = 0; size_t qblen, readlen; /* 如果启用了线程化 I/O，并且需要在退出事件循环时稍后读取客户端数据 */ if (postponeClientRead(c)) return; /* 更新服务器的总读取次数 */ atomicIncr(server.stat_total_reads_processed, 1); readlen = PROTO_IOBUF_LEN; /* 如果这是一个多批量请求，并且正在处理一个较大的批量回复，尽量确保查询缓冲区 * 精确包含表示对象的 SDS 字符串，即使这可能会导致更多的 read(2) 调用。 * 这样，函数 processMultiBulkBuffer() 可以避免复制缓冲区来创建 Redis 对象。 */ if (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != -1 &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG) { /* 对于大的参数，客户端总是使用其私有的查询缓冲区。 * 使用可重用的查询缓冲区可能会导致其超出 32k，最终让客户端接管这个缓冲区。 */ if (!c-&gt;querybuf) c-&gt;querybuf = sdsempty(); ssize_t remaining = (size_t)(c-&gt;bulklen+2)-(sdslen(c-&gt;querybuf)-c-&gt;qb_pos); big_arg = 1; /* 注意：&#39;remaining&#39; 变量在某些边缘情况下可能为零，例如当在 CLIENT PAUSE 后恢复被阻塞的客户端时 */ if (remaining &gt; 0) readlen = remaining; /* 如果是主客户端，在遇到大参数时需要扩大读取长度，但不需要对齐到下一个参数，可以读取更多数据 */ if (c-&gt;flags &amp; CLIENT_MASTER &amp;&amp; readlen &lt; PROTO_IOBUF_LEN) readlen = PROTO_IOBUF_LEN; } else if (c-&gt;querybuf == NULL) { if (unlikely(thread_reusable_qb_used)) { /* 如果可重用的查询缓冲区已被其他客户端使用，切换到使用客户端的私有查询缓冲区。 * 这种情况仅在通过 processEventsWhileBlocked() 执行嵌套命令时发生。 */ c-&gt;querybuf = sdsnewlen(NULL, PROTO_IOBUF_LEN); sdsclear(c-&gt;querybuf); } else { /* 如果查询缓冲区不存在，则创建可重用的查询缓冲区 */ if (!thread_reusable_qb) { thread_reusable_qb = sdsnewlen(NULL, PROTO_IOBUF_LEN); sdsclear(thread_reusable_qb); } /* 将可重用的查询缓冲区分配给客户端，并标记为正在使用 */ serverAssert(sdslen(thread_reusable_qb) == 0); c-&gt;querybuf = thread_reusable_qb; c-&gt;flags |= CLIENT_REUSABLE_QUERYBUFFER; thread_reusable_qb_used = 1; } } qblen = sdslen(c-&gt;querybuf); if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; // 主客户端的查询缓冲区可以贪婪扩展 (big_arg || sdsalloc(c-&gt;querybuf) &lt; PROTO_IOBUF_LEN)) { /* 在读取大参数时，我们不会读取超过一个参数的内容到查询缓冲区， * 所以不需要预分配多于所需的空间，因此使用非贪婪扩展。 */ c-&gt;querybuf = sdsMakeRoomForNonGreedy(c-&gt;querybuf, readlen); /* 稍后将峰值设置为已使用的部分，但这里我们过度分配，因为我们知道需要的空间，确保在使用前不会被缩小。 */ if (c-&gt;querybuf_peak &lt; qblen + readlen) c-&gt;querybuf_peak = qblen + readlen; } else { c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); /* 从套接字中尽可能多地读取数据，以节省 read(2) 系统调用次数。 */ readlen = sdsavail(c-&gt;querybuf); } nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen); if (nread == -1) { if (connGetState(conn) == CONN_STATE_CONNECTED) { goto done; } else { serverLog(LL_VERBOSE, &#34;从客户端读取数据时出错: %s&#34;, connGetLastError(c-&gt;conn)); freeClientAsync(c); goto done; } } else if (nread == 0) { if (server.verbosity &lt;= LL_VERBOSE) { sds info = catClientInfoString(sdsempty(), c); serverLog(LL_VERBOSE, &#34;客户端关闭了连接 %s&#34;, info); sdsfree(info); } freeClientAsync(c); goto done; } /* 更新查询缓冲区的长度 */ sdsIncrLen(c-&gt;querybuf, nread); qblen = sdslen(c-&gt;querybuf); if (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen; /* 更新最后交互时间 */ c-&gt;lastinteraction = server.unixtime; if (c-&gt;flags &amp; CLIENT_MASTER) { c-&gt;read_reploff += nread; atomicIncr(server.stat_net_repl_input_bytes, nread); } else { atomicIncr(server.stat_net_input_bytes, nread); } /* 对于普通客户端，如果查询缓冲区的大小超过限制或需要身份验证，则关闭客户端连接 */ if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; /* MULTI/EXEC 队列中的命令尚未执行，因此它们也算作查询缓冲区的一部分 */ (c-&gt;mstate.argv_len_sums + sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len || (c-&gt;mstate.argv_len_sums + sdslen(c-&gt;querybuf) &gt; 1024*1024 &amp;&amp; authRequired(c)))) { sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty(); bytes = sdscatrepr(bytes,c-&gt;querybuf,64); serverLog(LL_WARNING,&#34;关闭客户端，查询缓冲区超过最大限制: %s (查询缓冲区初始字节: %s)&#34;, ci, bytes); sdsfree(ci); sdsfree(bytes); freeClientAsync(c); atomicIncr(server.stat_client_qbuf_limit_disconnections, 1); goto done; } /* 如果客户端输入缓冲区还有数据，继续解析并检查是否有完整的命令需要执行 */ if (processInputBuffer(c) == C_ERR) c = NULL; done: if (c &amp;&amp; (c-&gt;flags &amp; CLIENT_REUSABLE_QUERYBUFFER)) { serverAssert(c-&gt;qb_pos == 0); /* 确保客户端的查询缓冲区在 processInputBuffer 中被修剪 */ resetReusableQueryBuf(c); } beforeNextClient(c); } processInputBuffer读取client请求信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* 该函数在每次客户端结构体 &#39;c&#39; 中有更多查询缓冲区需要处理时被调用， * 可能是因为我们从套接字读取了更多的数据，或者客户端被阻塞并在之后重新激活， * 所以可能存在待处理的查询缓冲区，这些缓冲区可能已经代表一个完整的命令需要处理。 * 如果在处理过程中客户端已经被释放，则返回 C_ERR */ int processInputBuffer(client *c) { /* 当输入缓冲区有内容时，继续处理 */ while(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) { /* 如果客户端当前被阻塞，立即中止 */ if (c-&gt;flags &amp; CLIENT_BLOCKED) break; /* 如果客户端有待处理的命令，不要继续处理更多的缓冲区 */ if (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) break; /* 如果客户端是主客户端，并且当前有忙碌脚本，暂停处理输入 */ if (isInsideYieldingLongCommand() &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) break; /* 如果设置了 CLIENT_CLOSE_AFTER_REPLY 标志，处理完回复后就关闭连接， * 不允许继续处理更多的命令 */ if (c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break; /* 如果请求类型未知，判断请求类型 */ if (!c-&gt;reqtype) { if (c-&gt;querybuf[c-&gt;qb_pos] == &#39;*&#39;) { c-&gt;reqtype = PROTO_REQ_MULTIBULK; // 多批量请求 } else { c-&gt;reqtype = PROTO_REQ_INLINE; // 单行命令 } } /* 根据请求类型处理缓冲区 */ if (c-&gt;reqtype == PROTO_REQ_INLINE) { if (processInlineBuffer(c) != C_OK) break; // 处理单行命令 } else if (c-&gt;reqtype == PROTO_REQ_MULTIBULK) { if (processMultibulkBuffer(c) != C_OK) break; // 处理多批量命令 } else { serverPanic(&#34;Unknown request type&#34;); // 未知的请求类型，程序崩溃 } /* 多批量请求处理可能导致 argc &lt;= 0 */ if (c-&gt;argc == 0) { resetClientInternal(c, 0); // 如果没有有效的参数，重置客户端 } else { /* 如果是 I/O 线程上下文，不能在此执行命令，只能标记客户端需要处理命令 */ if (io_threads_op != IO_THREADS_OP_IDLE) { serverAssert(io_threads_op == IO_THREADS_OP_READ); c-&gt;flags |= CLIENT_PENDING_COMMAND; // 设置为待处理命令状态 break; } /* 准备好执行命令了 */ if (processCommandAndResetClient(c) == C_ERR) { /* 如果客户端已经不再有效，避免继续执行，直接返回 */ return C_ERR; } } } /* 如果客户端是主客户端，需要裁剪查询缓冲区 */ if (c-&gt;flags &amp; CLIENT_MASTER) { /* 如果客户端是主客户端，裁剪查询缓冲区到 repl_applied 指定的位置， * 因为主客户端的查询缓冲区不仅用于解析命令，还用于代理给子复制实例。 * * 需要裁剪查询缓冲区的场景： * 1. 没有接收到完整的命令 * 2. 主客户端因为客户端暂停而被阻塞 * 3. I/O 线程操作读取，主客户端被标记为 CLIENT_PENDING_COMMAND * * 在这些场景下，qb_pos 指向当前命令的一部分或下一个命令的开始位置， * 当前命令尚未应用，因此 repl_applied 不等于 qb_pos。*/ if (c-&gt;repl_applied) { sdsrange(c-&gt;querybuf, c-&gt;repl_applied, -1); // 剩余的命令数据 c-&gt;qb_pos -= c-&gt;repl_applied; c-&gt;repl_applied = 0; } } else if (c-&gt;qb_pos) { /* 如果客户端不是主客户端，裁剪查询缓冲区 */ sdsrange(c-&gt;querybuf, c-&gt;qb_pos, -1); // 将查询缓冲区裁剪到当前位置 c-&gt;qb_pos = 0; // 重置查询缓冲区位置 } /* 在处理查询缓冲区后更新客户端的内存使用情况， * 这对查询缓冲区比较大且没有在上述循环中被完全处理的客户端很重要（ * 例如部分发送的大命令）。*/ if (io_threads_op == IO_THREADS_OP_IDLE) updateClientMemUsageAndBucket(c); return C_OK; // 返回处理成功 } 协议解析 processInlineBuffer：set a b这样的简单命令 processMultibulkBuffer：mset a b c d这样的复合命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 /* 类似于 processMultibulkBuffer()，但是用于处理 inline 协议，而不是 RESP 协议。 * 该函数消耗客户端的查询缓冲区，并在客户端结构体中创建一个准备执行的命令。 * 如果命令已经准备好执行，则返回 C_OK；如果仍然需要读取更多协议数据才能形成一个有效的命令，则返回 C_ERR。 * 当出现协议错误时，返回 C_ERR；在这种情况下，客户端结构体会被设置为回复错误并关闭连接。 */ int processInlineBuffer(client *c) { char *newline; int argc, j, linefeed_chars = 1; sds *argv, aux; size_t querylen; /* 查找换行符的位置 */ newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\n&#39;); /* 如果没有找到 \\r\\n 则返回，不做处理 */ if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big inline request&#34;); setProtocolError(&#34;too big inline request&#34;, c); } return C_ERR; } /* 处理 \\r\\n 的情况 */ if (newline != c-&gt;querybuf + c-&gt;qb_pos &amp;&amp; *(newline - 1) == &#39;\\r&#39;) { newline--; // 将 newline 指向 \\r 的前一个字符 linefeed_chars++; // 计算换行符的字符数 } /* 截取从当前指针到 \\r\\n 之间的内容 */ querylen = newline - (c-&gt;querybuf + c-&gt;qb_pos); aux = sdsnewlen(c-&gt;querybuf + c-&gt;qb_pos, querylen); // 创建一个新的 sds 字符串 argv = sdssplitargs(aux, &amp;argc); // 分割命令行参数 sdsfree(aux); // 释放临时变量 aux if (argv == NULL) { addReplyError(c, &#34;Protocol error: unbalanced quotes in request&#34;); setProtocolError(&#34;unbalanced quotes in inline request&#34;, c); return C_ERR; } /* 如果查询长度为 0 且客户端是从属节点， * 则表示通过换行符刷新最后的 ACK 时间。 * 这是为了让从属节点在加载大型 RDB 文件时能够持续保持连接 */ if (querylen == 0 &amp;&amp; clientTypeIsSlave(c)) { c-&gt;repl_ack_time = server.unixtime; } /* 主节点不应该发送 inline 协议来执行实际的命令。 * 如果发生这种情况，可能是 Redis 协议出现了同步问题， * 比如由于 PSYNC 出错导致的协议不一致。 * * 但是有一个例外：主节点可能只会发送一个换行符来保持连接活动。 */ if (querylen != 0 &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) { sdsfreesplitres(argv, argc); // 释放参数数组 serverLog(LL_WARNING, &#34;WARNING: Receiving inline protocol from master, master stream corruption? Closing the master connection and discarding the cached master.&#34;); setProtocolError(&#34;Master using the inline protocol. Desync?&#34;, c); return C_ERR; } /* 移动查询缓冲区位置，指向下一个查询命令 */ c-&gt;qb_pos += querylen + linefeed_chars; /* 在客户端结构体中设置 argv 数组 */ if (argc) { /* 如果参数数量超过当前分配的空间，重新分配内存 */ if (unlikely(argc &gt; c-&gt;argv_len)) { zfree(c-&gt;argv); // 释放旧的 argv c-&gt;argv = zmalloc(sizeof(robj*) * argc); // 分配新的 argv 数组 c-&gt;argv_len = argc; } c-&gt;argv_len_sum = 0; // 重置参数长度总和 } /* 为所有的参数创建 Redis 对象 */ for (c-&gt;argc = 0, j = 0; j &lt; argc; j++) { c-&gt;argv[c-&gt;argc] = createObject(OBJ_STRING, argv[j]); // 创建字符串类型的 Redis 对象 c-&gt;argc++; // 增加参数计数 c-&gt;argv_len_sum += sdslen(argv[j]); // 更新参数总长度 } zfree(argv); // 释放临时分割后的参数数组 return C_OK; // 返回命令已准备好执行 } /* 处理客户端 &#39;c&#39; 的查询缓冲区，并为命令执行设置客户端的参数向量。 * 如果客户端有一个格式正确、准备执行的命令，返回 C_OK， * 否则，如果还需要更多的数据才能获得完整的命令，返回 C_ERR。 * 如果出现协议错误，返回 C_ERR；在这种情况下，客户端结构会被设置为回复错误并关闭连接。 * * 当 processInputBuffer() 检测到下一个命令是 RESP 格式时会调用此函数， * 因为命令的第一个字节是 &#39;*&#39;。否则，对于 inline 命令会调用 processInlineBuffer()。*/ int processMultibulkBuffer(client *c) { char *newline = NULL; int ok; long long ll; if (c-&gt;multibulklen == 0) { /* 客户端应该已经被重置 */ serverAssertWithInfo(c, NULL, c-&gt;argc == 0); /* 多重批量长度不能在没有 \\r\\n 的情况下读取 */ newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\r&#39;); if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big mbulk count string&#34;); setProtocolError(&#34;too big mbulk count string&#34;, c); } return C_ERR; } /* 缓冲区中应也包含 \\n */ if (newline - (c-&gt;querybuf + c-&gt;qb_pos) &gt; (ssize_t)(sdslen(c-&gt;querybuf) - c-&gt;qb_pos - 2)) return C_ERR; /* 确定这是一整行，因为 newline != NULL， * 所以可以继续解析多重批量长度 */ serverAssertWithInfo(c, NULL, c-&gt;querybuf[c-&gt;qb_pos] == &#39;*&#39;); ok = string2ll(c-&gt;querybuf + 1 + c-&gt;qb_pos, newline - (c-&gt;querybuf + 1 + c-&gt;qb_pos), &amp;ll); if (!ok || ll &gt; INT_MAX) { addReplyError(c, &#34;Protocol error: invalid multibulk length&#34;); setProtocolError(&#34;invalid mbulk count&#34;, c); return C_ERR; } else if (ll &gt; 10 &amp;&amp; authRequired(c)) { addReplyError(c, &#34;Protocol error: unauthenticated multibulk length&#34;); setProtocolError(&#34;unauth mbulk count&#34;, c); return C_ERR; } c-&gt;qb_pos = (newline - c-&gt;querybuf) + 2; if (ll &lt;= 0) return C_OK; c-&gt;multibulklen = ll; /* 在客户端结构体中设置 argv 数组。 * 如果空间不足或者需要逐步分配空间，创建新的 argv */ if (unlikely(c-&gt;multibulklen &gt; c-&gt;argv_len || c-&gt;multibulklen &gt; 1024)) { zfree(c-&gt;argv); c-&gt;argv_len = min(c-&gt;multibulklen, 1024); c-&gt;argv = zmalloc(sizeof(robj*) * c-&gt;argv_len); } c-&gt;argv_len_sum = 0; } serverAssertWithInfo(c, NULL, c-&gt;multibulklen &gt; 0); while (c-&gt;multibulklen) { /* 如果未知，读取批量长度 */ if (c-&gt;bulklen == -1) { newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\r&#39;); if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big bulk count string&#34;); setProtocolError(&#34;too big bulk count string&#34;, c); return C_ERR; } break; } /* 缓冲区中也应该包含 \\n */ if (newline - (c-&gt;querybuf + c-&gt;qb_pos) &gt; (ssize_t)(sdslen(c-&gt;querybuf) - c-&gt;qb_pos - 2)) break; if (c-&gt;querybuf[c-&gt;qb_pos] != &#39;$&#39;) { addReplyErrorFormat(c, &#34;Protocol error: expected &#39;$&#39;, got &#39;%c&#39;&#34;, c-&gt;querybuf[c-&gt;qb_pos]); setProtocolError(&#34;expected $ but got something else&#34;, c); return C_ERR; } ok = string2ll(c-&gt;querybuf + c-&gt;qb_pos + 1, newline - (c-&gt;querybuf + c-&gt;qb_pos + 1), &amp;ll); if (!ok || ll &lt; 0 || (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; ll &gt; server.proto_max_bulk_len)) { addReplyError(c, &#34;Protocol error: invalid bulk length&#34;); setProtocolError(&#34;invalid bulk length&#34;, c); return C_ERR; } else if (ll &gt; 16384 &amp;&amp; authRequired(c)) { addReplyError(c, &#34;Protocol error: unauthenticated bulk length&#34;); setProtocolError(&#34;unauth bulk length&#34;, c); return C_ERR; } c-&gt;qb_pos = newline - c-&gt;querybuf + 2; if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; ll &gt;= PROTO_MBULK_BIG_ARG) { /* 如果客户端不是主节点（因为主节点的查询缓冲区只能在数据应用并发送给从节点后修剪）。 * * 如果我们将从网络读取一个较大的对象，尝试使其从 c-&gt;querybuf 边界开始，这样可以优化对象创建， * 避免对数据进行大量复制。 * * 但是只有当未解析的数据长度小于或等于 ll+2 时才这样做。否则，修剪查询缓冲区就是浪费时间， * 因为此时查询缓冲区不仅仅包含我们的大批量数据。 */ if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &lt;= (size_t)ll + 2) { sdsrange(c-&gt;querybuf, c-&gt;qb_pos, -1); c-&gt;qb_pos = 0; /* 提示 sds 库有关字符串长度的预期 */ c-&gt;querybuf = sdsMakeRoomForNonGreedy(c-&gt;querybuf, ll + 2 - sdslen(c-&gt;querybuf)); /* 我们后续会设置峰值为使用的部分，但此时超额分配是为了确保不会在使用前被缩小 */ if (c-&gt;querybuf_peak &lt; (size_t)ll + 2) c-&gt;querybuf_peak = ll + 2; } } c-&gt;bulklen = ll; } /* 读取批量参数 */ if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &lt; (size_t)(c-&gt;bulklen + 2)) { /* 数据不足（+2 是指尾部的 \\r\\n） */ break; } else { /* 检查是否有足够的空间存储参数，如果没有则进行扩展 */ if (c-&gt;argc &gt;= c-&gt;argv_len) { c-&gt;argv_len = min(c-&gt;argv_len &lt; INT_MAX / 2 ? c-&gt;argv_len * 2 : INT_MAX, c-&gt;argc + c-&gt;multibulklen); c-&gt;argv = zrealloc(c-&gt;argv, sizeof(robj*) * c-&gt;argv_len); } /* 优化：如果非主节点客户端的缓冲区仅包含我们的批量元素， * 那么直接使用当前的 sds 字符串而不是通过复制创建一个新的对象 */ if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; c-&gt;qb_pos == 0 &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG &amp;&amp; sdslen(c-&gt;querybuf) == (size_t)(c-&gt;bulklen + 2)) { c-&gt;argv[c-&gt;argc++] = createObject(OBJ_STRING, c-&gt;querybuf); c-&gt;argv_len_sum += c-&gt;bulklen; sdsIncrLen(c-&gt;querybuf, -2); /* 去除 CRLF */ /* 假设如果我们看到一个大的参数，接下来可能会看到另一个类似的 */ c-&gt;querybuf = sdsnewlen(SDS_NOINIT, c-&gt;bulklen + 2); sdsclear(c-&gt;querybuf); } else { c-&gt;argv[c-&gt;argc++] = createStringObject(c-&gt;querybuf + c-&gt;qb_pos, c-&gt;bulklen); c-&gt;argv_len_sum += c-&gt;bulklen; c-&gt;qb_pos += c-&gt;bulklen + 2; } c-&gt;bulklen = -1; c-&gt;multibulklen--; } } /* 当 c-&gt;multibulklen 为 0 时，表示命令处理完成 */ if (c-&gt;multibulklen == 0) return C_OK; /* 仍然没有准备好处理命令 */ return C_ERR; } processCommand处理命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 这个函数调用 processCommand()，同时执行一些对于客户端来说有用的额外任务： * * 1. 将当前客户端设置为 &#39;c&#39;。 * 2. 如果命令已处理，则调用 commandProcessed()。 * * 如果处理命令过程中客户端被释放，则返回 C_ERR，否则返回 C_OK。 */ int processCommandAndResetClient(client *c) { int deadclient = 0; client *old_client = server.current_client; // 设置当前处理的客户端为 &#39;c&#39; server.current_client = c; // 处理命令 if (processCommand(c) == C_OK) { // 如果命令成功处理，调用 commandProcessed() commandProcessed(c); // 更新客户端的内存使用情况，考虑到命令执行后可能导致输出缓冲区的增长 if (c-&gt;conn) updateClientMemUsageAndBucket(c); } // 检查当前客户端是否为空，如果为空表示客户端已经被释放 if (server.current_client == NULL) deadclient = 1; /* * 恢复之前的客户端设置。这个恢复是必要的，因为在脚本超时的情况下， * 我们会从 processEventsWhileBlocked 中进入该代码，这会导致设置 server.current_client。 * 如果不恢复，可能会错误地返回 1，表示客户端已经死掉，并停止从客户端缓冲区读取数据。 */ server.current_client = old_client; // performEvictions 可能会刷新从节点的输出缓冲区，这可能导致 // 从节点（可能是当前活动的客户端）被释放。 return deadclient ? C_ERR : C_OK; } 返回写入的resp给client：initServer -&gt; aeSetBeforeSleepProc -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads -&gt; sendReplyToClient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* 将数据写入客户端的输出缓冲区。如果客户端在调用后仍然有效，返回 C_OK， * 如果因错误而被释放，返回 C_ERR。如果设置了 handler_installed，则会尝试清除写事件。 * * 该函数由线程调用，但总是将 handler_installed 设置为 0。因此，当 handler_installed 设置为 0 时， * 该函数必须是线程安全的。*/ int writeToClient(client *c, int handler_installed) { /* 更新服务器的总写入次数 */ atomicIncr(server.stat_total_writes_processed, 1); ssize_t nwritten = 0, totwritten = 0; /* 循环写入客户端的待处理回复 */ while(clientHasPendingReplies(c)) { int ret = _writeToClient(c, &amp;nwritten); if (ret == C_ERR) break; totwritten += nwritten; /* 注意：我们避免一次写入超过 NET_MAX_WRITES_PER_EVENT 字节。 * 在单线程服务器中，即使来自超高速链接的大请求总是能接受数据， * 也应该服务其他客户端（在实际场景中可以考虑 &#39;KEYS *&#39; 命令通过回环接口）。 * * 然而，如果超出了最大内存限制，我们会忽略此限制，尽可能地发送数据。 * * 此外，如果客户端是从节点或监视器，我们会尽可能多地发送数据， * 否则，在高速流量下，复制/输出缓冲区可能会无限增长。*/ if (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp; (server.maxmemory == 0 || zmalloc_used_memory() &lt; server.maxmemory) &amp;&amp; !(c-&gt;flags &amp; CLIENT_SLAVE)) break; } /* 更新统计信息，记录已经发送的字节数 */ if (unlikely(clientTypeIsSlave(c))) { atomicIncr(server.stat_net_repl_output_bytes, totwritten); } else { atomicIncr(server.stat_net_output_bytes, totwritten); } /* 检查写入是否成功 */ if (nwritten == -1) { if (connGetState(c-&gt;conn) != CONN_STATE_CONNECTED) { serverLog(LL_VERBOSE, &#34;Error writing to client: %s&#34;, connGetLastError(c-&gt;conn)); freeClientAsync(c); return C_ERR; } } /* 如果有数据写入，更新客户端的最后交互时间 */ if (totwritten &gt; 0) { /* 对于表示主节点的客户端，不计算发送数据作为一次交互， * 因为我们总是发送 REPLCONF ACK 命令，这些命令只占用一些时间来填充套接字输出缓冲区。 * 我们仅依赖接收到的数据或 ping 命令来检测超时。 */ if (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime; } /* 如果客户端没有待处理的回复 */ if (!clientHasPendingReplies(c)) { c-&gt;sentlen = 0; /* 请注意，writeToClient() 是在线程中调用的，但 aeDeleteFileEvent() 不是线程安全的： * 然而，由于 writeToClient() 总是在线程中将 handler_installed 设置为 0， * 所以我们可以放心。*/ if (handler_installed) { serverAssert(io_threads_op == IO_THREADS_OP_IDLE); connSetWriteHandler(c-&gt;conn, NULL); } /* 在发送完整回复后关闭连接。 */ if (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) { freeClientAsync(c); return C_ERR; } } /* 在写入数据后更新客户端的内存使用情况。 * 由于这不是线程安全的，所以我们会有条件地执行此操作。 * 如果是多线程写入，则将在 handleClientsWithPendingWritesUsingThreads() 中处理。*/ if (io_threads_op == IO_THREADS_OP_IDLE) updateClientMemUsageAndBucket(c); return C_OK; } 内核函数分析 doc：https://man7.org/linux/man-pages/man7/epoll.7.html\n">
<title>高性能 reids-通信</title>

<link rel='canonical' href='http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD-reids-%E9%80%9A%E4%BF%A1/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="高性能 reids-通信">
<meta property='og:description' content="redis通信 源码分析 系统初始化 &amp; eventloop事件循环总线构建 从main函数说起（原300+行，精简部分非核心内容后包含注释100+行） 网络通信相关主要为：在main函数中启动epoll监听，io多路复用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 int main(int argc, char **argv) { struct timeval tv; int j; char config_from_stdin = 0; /* 系统基础依赖初始化： 1. 时区设置 2. 内存oom处理方法 3. 随机数/哈希种子生成 4. crc64校验码初始化 */ char *exec_name = strrchr(argv[0], &#39;/&#39;); if (exec_name == NULL) exec_name = argv[0]; server.sentinel_mode = checkForSentinelMode(argc,argv, exec_name); initServerConfig(); ACLInit(); /* 初始化 ACL（访问控制列表）系统，网络连接时需要根据ACL控制权限，此时未加载实际配置 */ moduleInitModulesSystem(); connTypeInitialize(); /* 存储可执行文件路径和启动参数，用于以后重启服务器 */ server.executable = getAbsolutePath(argv[0]); server.exec_argv = zmalloc(sizeof(char*)*(argc+1)); server.exec_argv[argc] = NULL; for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]); /* 初始化 Sentinel 相关配置（如果是 Sentinel 模式） */ if (server.sentinel_mode) { initSentinelConfig(); initSentinel(); } /* 检查是否需要启动 redis-check-rdb 或 redis-check-aof 模式 */ if (strstr(exec_name,&#34;redis-check-rdb&#34;) != NULL) redis_check_rdb_main(argc,argv,NULL); else if (strstr(exec_name,&#34;redis-check-aof&#34;) != NULL) redis_check_aof_main(argc,argv); /* 参数解析 */ if (argc &gt;= 2) { j = 1; sds options = sdsempty(); // 使用内部定义的sds字符串结构 /* 解析特殊参数 --version，--help */ if (strcmp(argv[1], &#34;-v&#34;) == 0 || strcmp(argv[1], &#34;--version&#34;) == 0) { sds version = getVersion(); printf(&#34;Redis server %s\\n&#34;, version); sdsfree(version); exit(0); } if (strcmp(argv[1], &#34;--help&#34;) == 0 || strcmp(argv[1], &#34;-h&#34;) == 0) usage(); sds *argv_tmp; int argc_tmp; int handled_last_config_arg = 1; while(j &lt; argc) { /* 遍历解析参数 */ j++; } /* 根据参数完成必要文件配置的加载 */ loadServerConfig(server.configfile, config_from_stdin, options); if (server.sentinel_mode) loadSentinelConfigFromQueue(); sdsfree(options); } if (server.sentinel_mode) sentinelCheckConfigFile(); /* 核心：启动服务 */ initServer(); // 核心中的核心：载入server对象相关的核心组件：signal信号处理器，thread线程管理器，eventloop事件处理总线等 if (background || server.pidfile) createPidFile(); if (server.set_proc_title) redisSetProcTitle(NULL); redisAsciiArt(); // 打印启动redis的ASCII文字 checkTcpBacklogSettings(); if (server.cluster_enabled) { clusterInit(); } if (!server.sentinel_mode) { moduleInitModulesSystemLast(); moduleLoadFromQueue(); } // acl读取实际配置 ACLLoadUsersAtStartup(); initListeners(); if (server.cluster_enabled) { clusterInitLast(); } InitServerLast(); if (!server.sentinel_mode) { // 非sentinel模式 serverLog(LL_NOTICE,&#34;Server initialized&#34;); aofLoadManifestFromDisk(); loadDataFromDisk(); aofOpenIfNeededOnServerStart(); aofDelHistoryFiles(); applyAppendOnlyConfig(); // 集群模式校验 if (server.cluster_enabled) { serverAssert(verifyClusterConfigWithData() == C_OK); } // 打印所有监听器的状态 for (j = 0; j &lt; CONN_TYPE_MAX; j++) { connListener *listener = &amp;server.listeners[j]; if (listener-&gt;ct == NULL) continue; serverLog(LL_NOTICE,&#34;Ready to accept connections %s&#34;, listener-&gt;ct-&gt;get_type(NULL)); } if (server.supervised_mode == SUPERVISED_SYSTEMD) { // 如果是由 systemd 监督运行的 Redis 实例，通知 systemd Redis 状态 } } else { sentinelIsRunning(); if (server.supervised_mode == SUPERVISED_SYSTEMD) { // 如果是由 systemd 监督运行的 sentinel 实例，通知 systemd sentinel 状态 } } /* 内存分配过小（1MB）警告 */ if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) { serverLog(LL_WARNING,&#34;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&#34;, server.maxmemory); } redisSetCpuAffinity(server.server_cpulist); setOOMScoreAdj(-1); // epoll监听，io多路复用，死循环 aeMain(server.el); aeDeleteEventLoop(server.el); return 0; } 核心中的核心：initServer方法，载入server对象相关的核心组件：signal信号处理器，thread线程管理器，eventloop事件处理总线等。（原200+行，精简部分非核心内容后包含注释60+行） 网络通信相关主要为：在初始化函数中创建thread线程管理器，eventloop事件处理总线 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 void initServer(void) { // 信号处理器，例如ctrl+c发送SIGKILL信号，此时需要关闭服务 setupSignalHandlers(); // 线程管理器初始化 ThreadsManager_init(); makeThreadKillable(); /* 在从配置系统设置默认值后进行初始化 */ server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF; server.fsynced_reploff = server.aof_enabled ? 0 : -1; server.hz = server.config_hz; // 心跳频率 server.pid = getpid(); // 创建eventloop事件处理总线，基于epoll机制（linux） server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR); if (server.el == NULL) { serverLog(LL_WARNING, &#34;Failed creating the event loop. Error message: &#39;%s&#39;&#34;, strerror(errno)); exit(1); } /* 创建定时器回调，这是我们处理许多后台操作的方式， 比如客户端超时、未访问的过期键的淘汰等 */ if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) { serverPanic(&#34;Can&#39;t create event loop timers.&#34;); exit(1); } /* 为用于唤醒事件循环的管道注册一个可读事件， 用于模块线程间的通信 */ if (aeCreateFileEvent(server.el, server.module_pipe[0], AE_READABLE, modulePipeReadable,NULL) == AE_ERR) { serverPanic( &#34;Error registering the readable event for the module pipe.&#34;); } /* 注册epoll阻塞前后的回调函数（需在加载持久化之前完成，因为它会被 processEventsWhileBlocked 使用） */ aeSetBeforeSleepProc(server.el,beforeSleep); aeSetAfterSleepProc(server.el,afterSleep); /* 32位老系统受限于寻址上限32bit，最多访问2^32个字节，也就是4294967296B -&gt; 4GB，redis会默认限制3GB上限 */ if (server.arch_bits == 32 &amp;&amp; server.maxmemory == 0) { serverLog(LL_WARNING,&#34;Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with &#39;noeviction&#39; policy now.&#34;); server.maxmemory = 3072LL*(1024*1024); /* 3 GB */ server.maxmemory_policy = MAXMEMORY_NO_EVICTION; } // 脚本系统初始化 luaEnvInit(); scriptingInit(1); if (functionsInit() == C_ERR) { serverPanic(&#34;Functions initialization failed, check the server logs.&#34;); exit(1); } // 基本监控初始化：提供慢查询告警/延迟监控等功能 slowlogInit(); latencyMonitorInit(); // 参照配置初始化密码，一般不启用 ACLUpdateDefaultUserPassword(server.requirepass); // 定时器功能初始化 applyWatchdogPeriod(); if (server.maxmemory_clients != 0) initServerClientMemUsageBuckets(); } aeCreateEventLoop方法：创建事件循环总线 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 aeEventLoop *aeCreateEventLoop(int setsize) { aeEventLoop *eventLoop; monotonicInit(); /* just in case the calling app didn&#39;t initialize */ // 分配内存：最大感兴趣的fd为setsize if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err; eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize); eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize); if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err; eventLoop-&gt;setsize = setsize; eventLoop-&gt;timeEventHead = NULL; eventLoop-&gt;timeEventNextId = 0; eventLoop-&gt;stop = 0; eventLoop-&gt;maxfd = -1; eventLoop-&gt;beforesleep = NULL; eventLoop-&gt;aftersleep = NULL; eventLoop-&gt;flags = 0; if (aeApiCreate(eventLoop) == -1) goto err; // 核心：调用封装的函数aeApiCreate /* Events的关注事件默认置为0（不关注任何事件）*/ for (int i = 0; i &lt; setsize; i++) eventLoop-&gt;events[i].mask = AE_NONE; return eventLoop; err: // 失败则释放内存 if (eventLoop) { zfree(eventLoop-&gt;events); zfree(eventLoop-&gt;fired); zfree(eventLoop); } return NULL; } /* ae_epoll.c，仅在上面代码中调用，创建事件总线\t这里依赖系统内置库函数：epoll_create，其中size参数仅为参考值，对较新的linux版本来说无实际作用 */ static int aeApiCreate(aeEventLoop *eventLoop) { aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize); if (!state-&gt;events) { zfree(state); return -1; } state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */ if (state-&gt;epfd == -1) { zfree(state-&gt;events); zfree(state); return -1; } anetCloexec(state-&gt;epfd); eventLoop-&gt;apidata = state; return 0; } ae_epoll.c封装系统库函数（无精简） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 #include &lt;sys/epoll.h&gt; typedef struct aeApiState { int epfd; struct epoll_event *events; } aeApiState; /* 仅在aeCreateEventLoop代码中调用，创建事件总线\t依赖系统内置库函数：epoll_create，其中： size参数仅为参考值，对较新的linux版本来说无实际作用 */ static int aeApiCreate(aeEventLoop *eventLoop) { aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize); if (!state-&gt;events) { zfree(state); return -1; } state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */ if (state-&gt;epfd == -1) { zfree(state-&gt;events); zfree(state); return -1; } anetCloexec(state-&gt;epfd); eventLoop-&gt;apidata = state; return 0; } // resize event数组，类似vector(c)/list(java)/slice(golang/python)动态扩容 static int aeApiResize(aeEventLoop *eventLoop, int setsize) { aeApiState *state = eventLoop-&gt;apidata; state-&gt;events = zrealloc(state-&gt;events, sizeof(struct epoll_event)*setsize); return 0; } // 释放资源 static void aeApiFree(aeEventLoop *eventLoop) { aeApiState *state = eventLoop-&gt;apidata; close(state-&gt;epfd); zfree(state-&gt;events); zfree(state); } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_ctl，其中： epfd为事件总线fd， op为注册操作，枚举EPOLL_CTL_ADD, EPOLL_CTL_ADD, EPOLL_CTL_DEL， fd为注册的新fd， ee为新建的epoll_event结构体实例 */ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) { aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee = {0}; /* avoid valgrind warning */ /* If the fd was already monitored for some event, we need a MOD * operation. Otherwise we need an ADD operation. */ int op = eventLoop-&gt;events[fd].mask == AE_NONE ? EPOLL_CTL_ADD : EPOLL_CTL_MOD; ee.events = 0; mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */ if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.fd = fd; if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1; return 0; } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_ctl，其中： epfd为事件总线fd， op为注册操作，枚举EPOLL_CTL_ADD, EPOLL_CTL_ADD, EPOLL_CTL_DEL， fd为注册的新fd， ee为新建的epoll_event结构体实例，关注的mask写在这个结构体中 */ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) { aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee = {0}; /* avoid valgrind warning */ int mask = eventLoop-&gt;events[fd].mask &amp; (~delmask); ee.events = 0; if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.fd = fd; if (mask != AE_NONE) { epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee); } else { /* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for * EPOLL_CTL_DEL. */ epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee); } } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_wait，其中： epfd为事件总线fd， events为已注册的全部感兴趣事件， tvp相关为等待时间，-1为一直阻塞，直到有注册的感兴趣事件发生 */ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) { aeApiState *state = eventLoop-&gt;apidata; int retval, numevents = 0; retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize, tvp ? (tvp-&gt;tv_sec*1000 + (tvp-&gt;tv_usec + 999)/1000) : -1); if (retval &gt; 0) { int j; numevents = retval; for (j = 0; j &lt; numevents; j++) { int mask = 0; struct epoll_event *e = state-&gt;events+j; if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE; if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE; if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE|AE_READABLE; if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE; eventLoop-&gt;fired[j].fd = e-&gt;data.fd; eventLoop-&gt;fired[j].mask = mask; } } else if (retval == -1 &amp;&amp; errno != EINTR) { panic(&#34;aeApiPoll: epoll_wait, %s&#34;, strerror(errno)); } return numevents; } static char *aeApiName(void) { return &#34;epoll&#34;; } 哪些地方调用了注册事件 server启动过程中：initListeners -&gt; createSocketAcceptHandler （accept） connSocketAcceptHandler 创建客户端连接时：ConnectionType -&gt; connSocketConnect（connect） ae_handler -&gt; connSocketSetReadHandler 建立client通信时：createClient -&gt; readQueryFromClient ae_handler -&gt; connSocketSetWriteHandler 初始化服务端时：initServer -&gt; aeSetBeforeSleepProc -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads -&gt; sendReplyToClient 同步rdb数据：initServer -&gt; aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) -&gt; serverCron -&gt; checkChildrenDone -&gt; replicationStartPendingFork -&gt; rdbSaveToSlavesSockets rdbPipeReadHandler sentinel通信：initServer -&gt; aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) -&gt; serverCron -&gt; sentinelTimer -&gt; sentinelHandleDictOfRedisInstances -&gt; sentinelHandleRedisInstance -&gt; sentinelReconnectInstance -&gt; redisAeAttach -&gt; redisAeAddWrite pipeline管道的bio通信：initServer -&gt; InitServerLast -&gt; bioInit 注册事件处理：main -&gt; aeMain -&gt; aeApiPoll -&gt; epoll_wait 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 // 死循环处理事件 void aeMain(aeEventLoop *eventLoop) { eventLoop-&gt;stop = 0; while (!eventLoop-&gt;stop) { aeProcessEvents(eventLoop, AE_ALL_EVENTS| AE_CALL_BEFORE_SLEEP| AE_CALL_AFTER_SLEEP); } } typedef struct aeEventLoop { int maxfd; /* highest file descriptor currently registered */ int setsize; /* max number of file descriptors tracked */ long long timeEventNextId; aeFileEvent *events; /* Registered events */ aeFiredEvent *fired; /* Fired events */ aeTimeEvent *timeEventHead; int stop; void *apidata; /* This is used for polling API specific data */ aeBeforeSleepProc *beforesleep; aeBeforeSleepProc *aftersleep; int flags; } aeEventLoop; typedef struct aeFileEvent { int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */ aeFileProc *rfileProc; aeFileProc *wfileProc; void *clientData; } aeFileEvent; int aeProcessEvents(aeEventLoop *eventLoop, int flags) { int processed = 0, numevents; /* 如果没有文件事件和时间事件需要处理，直接返回 */ if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0; /* 即使没有文件事件，如果有时间事件，也需要调用 aeApiPoll 来等待下一次时间事件的触发 */ if (eventLoop-&gt;maxfd != -1 || ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) { int j; struct timeval tv, *tvp = NULL; /* NULL means infinite wait. */ int64_t usUntilTimer; if (eventLoop-&gt;beforesleep != NULL &amp;&amp; (flags &amp; AE_CALL_BEFORE_SLEEP)) /* Before sleep callback. */ eventLoop-&gt;beforesleep(eventLoop); /* eventLoop-&gt;flags 可能会在 beforeSleep 中发生改变，所以需要在调用 beforeSleep 后重新检查 同时，flags 参数优先级更高，特别是 AE_DONT_WAIT 设置时，应忽略 eventLoop-&gt;flags 中的值 */ if ((flags &amp; AE_DONT_WAIT) || (eventLoop-&gt;flags &amp; AE_DONT_WAIT)) { tv.tv_sec = tv.tv_usec = 0; tvp = &amp;tv; } else if (flags &amp; AE_TIME_EVENTS) { usUntilTimer = usUntilEarliestTimer(eventLoop); if (usUntilTimer &gt;= 0) { tv.tv_sec = usUntilTimer / 1000000; tv.tv_usec = usUntilTimer % 1000000; tvp = &amp;tv; } } /* 调用aeApiPoll多路复用方法，Call the multiplexing API, will return only on timeout or when some event fires. */ numevents = aeApiPoll(eventLoop, tvp); /* 如果没有请求处理文件事件，就跳过文件事件的处理 */ if (!(flags &amp; AE_FILE_EVENTS)) { numevents = 0; } /* After sleep callback. */ if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP) eventLoop-&gt;aftersleep(eventLoop); for (j = 0; j &lt; numevents; j++) { int fd = eventLoop-&gt;fired[j].fd; aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; int mask = eventLoop-&gt;fired[j].mask; int fired = 0; /* Number of events fired for current fd. */ /* 默认情况下，先执行可读事件，再执行可写事件。这个顺序可以确保有可读数据时，优先处理读取请求。 * 如果设置了 AE_BARRIER 标志，则表示我们希望反转执行顺序，先执行可写事件。 */ int invert = fe-&gt;mask &amp; AE_BARRIER; /* 检查事件是否仍然有效：可能已经处理过的事件在当前回合中已经被移除 */ if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) { fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */ } /* 执行可写事件 */ if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) { if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) { fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; } } /* 如果需要反转执行顺序，在可写事件后执行可读事件 */ if (invert) { fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */ if ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp; (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) { fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; } } processed++; } } /* 如果需要处理时间事件，则继续处理时间事件 */ if (flags &amp; AE_TIME_EVENTS) processed += processTimeEvents(eventLoop); return processed; } 多路复用处理方法（类似netty中的handler实现） 协议解析：createClient -&gt; readQueryFromClient -&gt; processInputBuffer -&gt; processXXXBuffer -&gt; processCommandAndResetClient inline：processInlineBuffer multi：processMultibulkBuffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 void readQueryFromClient(connection *conn) { client *c = connGetPrivateData(conn); int nread, big_arg = 0; size_t qblen, readlen; /* 如果启用了线程化 I/O，并且需要在退出事件循环时稍后读取客户端数据 */ if (postponeClientRead(c)) return; /* 更新服务器的总读取次数 */ atomicIncr(server.stat_total_reads_processed, 1); readlen = PROTO_IOBUF_LEN; /* 如果这是一个多批量请求，并且正在处理一个较大的批量回复，尽量确保查询缓冲区 * 精确包含表示对象的 SDS 字符串，即使这可能会导致更多的 read(2) 调用。 * 这样，函数 processMultiBulkBuffer() 可以避免复制缓冲区来创建 Redis 对象。 */ if (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != -1 &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG) { /* 对于大的参数，客户端总是使用其私有的查询缓冲区。 * 使用可重用的查询缓冲区可能会导致其超出 32k，最终让客户端接管这个缓冲区。 */ if (!c-&gt;querybuf) c-&gt;querybuf = sdsempty(); ssize_t remaining = (size_t)(c-&gt;bulklen+2)-(sdslen(c-&gt;querybuf)-c-&gt;qb_pos); big_arg = 1; /* 注意：&#39;remaining&#39; 变量在某些边缘情况下可能为零，例如当在 CLIENT PAUSE 后恢复被阻塞的客户端时 */ if (remaining &gt; 0) readlen = remaining; /* 如果是主客户端，在遇到大参数时需要扩大读取长度，但不需要对齐到下一个参数，可以读取更多数据 */ if (c-&gt;flags &amp; CLIENT_MASTER &amp;&amp; readlen &lt; PROTO_IOBUF_LEN) readlen = PROTO_IOBUF_LEN; } else if (c-&gt;querybuf == NULL) { if (unlikely(thread_reusable_qb_used)) { /* 如果可重用的查询缓冲区已被其他客户端使用，切换到使用客户端的私有查询缓冲区。 * 这种情况仅在通过 processEventsWhileBlocked() 执行嵌套命令时发生。 */ c-&gt;querybuf = sdsnewlen(NULL, PROTO_IOBUF_LEN); sdsclear(c-&gt;querybuf); } else { /* 如果查询缓冲区不存在，则创建可重用的查询缓冲区 */ if (!thread_reusable_qb) { thread_reusable_qb = sdsnewlen(NULL, PROTO_IOBUF_LEN); sdsclear(thread_reusable_qb); } /* 将可重用的查询缓冲区分配给客户端，并标记为正在使用 */ serverAssert(sdslen(thread_reusable_qb) == 0); c-&gt;querybuf = thread_reusable_qb; c-&gt;flags |= CLIENT_REUSABLE_QUERYBUFFER; thread_reusable_qb_used = 1; } } qblen = sdslen(c-&gt;querybuf); if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; // 主客户端的查询缓冲区可以贪婪扩展 (big_arg || sdsalloc(c-&gt;querybuf) &lt; PROTO_IOBUF_LEN)) { /* 在读取大参数时，我们不会读取超过一个参数的内容到查询缓冲区， * 所以不需要预分配多于所需的空间，因此使用非贪婪扩展。 */ c-&gt;querybuf = sdsMakeRoomForNonGreedy(c-&gt;querybuf, readlen); /* 稍后将峰值设置为已使用的部分，但这里我们过度分配，因为我们知道需要的空间，确保在使用前不会被缩小。 */ if (c-&gt;querybuf_peak &lt; qblen + readlen) c-&gt;querybuf_peak = qblen + readlen; } else { c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); /* 从套接字中尽可能多地读取数据，以节省 read(2) 系统调用次数。 */ readlen = sdsavail(c-&gt;querybuf); } nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen); if (nread == -1) { if (connGetState(conn) == CONN_STATE_CONNECTED) { goto done; } else { serverLog(LL_VERBOSE, &#34;从客户端读取数据时出错: %s&#34;, connGetLastError(c-&gt;conn)); freeClientAsync(c); goto done; } } else if (nread == 0) { if (server.verbosity &lt;= LL_VERBOSE) { sds info = catClientInfoString(sdsempty(), c); serverLog(LL_VERBOSE, &#34;客户端关闭了连接 %s&#34;, info); sdsfree(info); } freeClientAsync(c); goto done; } /* 更新查询缓冲区的长度 */ sdsIncrLen(c-&gt;querybuf, nread); qblen = sdslen(c-&gt;querybuf); if (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen; /* 更新最后交互时间 */ c-&gt;lastinteraction = server.unixtime; if (c-&gt;flags &amp; CLIENT_MASTER) { c-&gt;read_reploff += nread; atomicIncr(server.stat_net_repl_input_bytes, nread); } else { atomicIncr(server.stat_net_input_bytes, nread); } /* 对于普通客户端，如果查询缓冲区的大小超过限制或需要身份验证，则关闭客户端连接 */ if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; /* MULTI/EXEC 队列中的命令尚未执行，因此它们也算作查询缓冲区的一部分 */ (c-&gt;mstate.argv_len_sums + sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len || (c-&gt;mstate.argv_len_sums + sdslen(c-&gt;querybuf) &gt; 1024*1024 &amp;&amp; authRequired(c)))) { sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty(); bytes = sdscatrepr(bytes,c-&gt;querybuf,64); serverLog(LL_WARNING,&#34;关闭客户端，查询缓冲区超过最大限制: %s (查询缓冲区初始字节: %s)&#34;, ci, bytes); sdsfree(ci); sdsfree(bytes); freeClientAsync(c); atomicIncr(server.stat_client_qbuf_limit_disconnections, 1); goto done; } /* 如果客户端输入缓冲区还有数据，继续解析并检查是否有完整的命令需要执行 */ if (processInputBuffer(c) == C_ERR) c = NULL; done: if (c &amp;&amp; (c-&gt;flags &amp; CLIENT_REUSABLE_QUERYBUFFER)) { serverAssert(c-&gt;qb_pos == 0); /* 确保客户端的查询缓冲区在 processInputBuffer 中被修剪 */ resetReusableQueryBuf(c); } beforeNextClient(c); } processInputBuffer读取client请求信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* 该函数在每次客户端结构体 &#39;c&#39; 中有更多查询缓冲区需要处理时被调用， * 可能是因为我们从套接字读取了更多的数据，或者客户端被阻塞并在之后重新激活， * 所以可能存在待处理的查询缓冲区，这些缓冲区可能已经代表一个完整的命令需要处理。 * 如果在处理过程中客户端已经被释放，则返回 C_ERR */ int processInputBuffer(client *c) { /* 当输入缓冲区有内容时，继续处理 */ while(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) { /* 如果客户端当前被阻塞，立即中止 */ if (c-&gt;flags &amp; CLIENT_BLOCKED) break; /* 如果客户端有待处理的命令，不要继续处理更多的缓冲区 */ if (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) break; /* 如果客户端是主客户端，并且当前有忙碌脚本，暂停处理输入 */ if (isInsideYieldingLongCommand() &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) break; /* 如果设置了 CLIENT_CLOSE_AFTER_REPLY 标志，处理完回复后就关闭连接， * 不允许继续处理更多的命令 */ if (c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break; /* 如果请求类型未知，判断请求类型 */ if (!c-&gt;reqtype) { if (c-&gt;querybuf[c-&gt;qb_pos] == &#39;*&#39;) { c-&gt;reqtype = PROTO_REQ_MULTIBULK; // 多批量请求 } else { c-&gt;reqtype = PROTO_REQ_INLINE; // 单行命令 } } /* 根据请求类型处理缓冲区 */ if (c-&gt;reqtype == PROTO_REQ_INLINE) { if (processInlineBuffer(c) != C_OK) break; // 处理单行命令 } else if (c-&gt;reqtype == PROTO_REQ_MULTIBULK) { if (processMultibulkBuffer(c) != C_OK) break; // 处理多批量命令 } else { serverPanic(&#34;Unknown request type&#34;); // 未知的请求类型，程序崩溃 } /* 多批量请求处理可能导致 argc &lt;= 0 */ if (c-&gt;argc == 0) { resetClientInternal(c, 0); // 如果没有有效的参数，重置客户端 } else { /* 如果是 I/O 线程上下文，不能在此执行命令，只能标记客户端需要处理命令 */ if (io_threads_op != IO_THREADS_OP_IDLE) { serverAssert(io_threads_op == IO_THREADS_OP_READ); c-&gt;flags |= CLIENT_PENDING_COMMAND; // 设置为待处理命令状态 break; } /* 准备好执行命令了 */ if (processCommandAndResetClient(c) == C_ERR) { /* 如果客户端已经不再有效，避免继续执行，直接返回 */ return C_ERR; } } } /* 如果客户端是主客户端，需要裁剪查询缓冲区 */ if (c-&gt;flags &amp; CLIENT_MASTER) { /* 如果客户端是主客户端，裁剪查询缓冲区到 repl_applied 指定的位置， * 因为主客户端的查询缓冲区不仅用于解析命令，还用于代理给子复制实例。 * * 需要裁剪查询缓冲区的场景： * 1. 没有接收到完整的命令 * 2. 主客户端因为客户端暂停而被阻塞 * 3. I/O 线程操作读取，主客户端被标记为 CLIENT_PENDING_COMMAND * * 在这些场景下，qb_pos 指向当前命令的一部分或下一个命令的开始位置， * 当前命令尚未应用，因此 repl_applied 不等于 qb_pos。*/ if (c-&gt;repl_applied) { sdsrange(c-&gt;querybuf, c-&gt;repl_applied, -1); // 剩余的命令数据 c-&gt;qb_pos -= c-&gt;repl_applied; c-&gt;repl_applied = 0; } } else if (c-&gt;qb_pos) { /* 如果客户端不是主客户端，裁剪查询缓冲区 */ sdsrange(c-&gt;querybuf, c-&gt;qb_pos, -1); // 将查询缓冲区裁剪到当前位置 c-&gt;qb_pos = 0; // 重置查询缓冲区位置 } /* 在处理查询缓冲区后更新客户端的内存使用情况， * 这对查询缓冲区比较大且没有在上述循环中被完全处理的客户端很重要（ * 例如部分发送的大命令）。*/ if (io_threads_op == IO_THREADS_OP_IDLE) updateClientMemUsageAndBucket(c); return C_OK; // 返回处理成功 } 协议解析 processInlineBuffer：set a b这样的简单命令 processMultibulkBuffer：mset a b c d这样的复合命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 /* 类似于 processMultibulkBuffer()，但是用于处理 inline 协议，而不是 RESP 协议。 * 该函数消耗客户端的查询缓冲区，并在客户端结构体中创建一个准备执行的命令。 * 如果命令已经准备好执行，则返回 C_OK；如果仍然需要读取更多协议数据才能形成一个有效的命令，则返回 C_ERR。 * 当出现协议错误时，返回 C_ERR；在这种情况下，客户端结构体会被设置为回复错误并关闭连接。 */ int processInlineBuffer(client *c) { char *newline; int argc, j, linefeed_chars = 1; sds *argv, aux; size_t querylen; /* 查找换行符的位置 */ newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\n&#39;); /* 如果没有找到 \\r\\n 则返回，不做处理 */ if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big inline request&#34;); setProtocolError(&#34;too big inline request&#34;, c); } return C_ERR; } /* 处理 \\r\\n 的情况 */ if (newline != c-&gt;querybuf + c-&gt;qb_pos &amp;&amp; *(newline - 1) == &#39;\\r&#39;) { newline--; // 将 newline 指向 \\r 的前一个字符 linefeed_chars++; // 计算换行符的字符数 } /* 截取从当前指针到 \\r\\n 之间的内容 */ querylen = newline - (c-&gt;querybuf + c-&gt;qb_pos); aux = sdsnewlen(c-&gt;querybuf + c-&gt;qb_pos, querylen); // 创建一个新的 sds 字符串 argv = sdssplitargs(aux, &amp;argc); // 分割命令行参数 sdsfree(aux); // 释放临时变量 aux if (argv == NULL) { addReplyError(c, &#34;Protocol error: unbalanced quotes in request&#34;); setProtocolError(&#34;unbalanced quotes in inline request&#34;, c); return C_ERR; } /* 如果查询长度为 0 且客户端是从属节点， * 则表示通过换行符刷新最后的 ACK 时间。 * 这是为了让从属节点在加载大型 RDB 文件时能够持续保持连接 */ if (querylen == 0 &amp;&amp; clientTypeIsSlave(c)) { c-&gt;repl_ack_time = server.unixtime; } /* 主节点不应该发送 inline 协议来执行实际的命令。 * 如果发生这种情况，可能是 Redis 协议出现了同步问题， * 比如由于 PSYNC 出错导致的协议不一致。 * * 但是有一个例外：主节点可能只会发送一个换行符来保持连接活动。 */ if (querylen != 0 &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) { sdsfreesplitres(argv, argc); // 释放参数数组 serverLog(LL_WARNING, &#34;WARNING: Receiving inline protocol from master, master stream corruption? Closing the master connection and discarding the cached master.&#34;); setProtocolError(&#34;Master using the inline protocol. Desync?&#34;, c); return C_ERR; } /* 移动查询缓冲区位置，指向下一个查询命令 */ c-&gt;qb_pos += querylen + linefeed_chars; /* 在客户端结构体中设置 argv 数组 */ if (argc) { /* 如果参数数量超过当前分配的空间，重新分配内存 */ if (unlikely(argc &gt; c-&gt;argv_len)) { zfree(c-&gt;argv); // 释放旧的 argv c-&gt;argv = zmalloc(sizeof(robj*) * argc); // 分配新的 argv 数组 c-&gt;argv_len = argc; } c-&gt;argv_len_sum = 0; // 重置参数长度总和 } /* 为所有的参数创建 Redis 对象 */ for (c-&gt;argc = 0, j = 0; j &lt; argc; j++) { c-&gt;argv[c-&gt;argc] = createObject(OBJ_STRING, argv[j]); // 创建字符串类型的 Redis 对象 c-&gt;argc++; // 增加参数计数 c-&gt;argv_len_sum += sdslen(argv[j]); // 更新参数总长度 } zfree(argv); // 释放临时分割后的参数数组 return C_OK; // 返回命令已准备好执行 } /* 处理客户端 &#39;c&#39; 的查询缓冲区，并为命令执行设置客户端的参数向量。 * 如果客户端有一个格式正确、准备执行的命令，返回 C_OK， * 否则，如果还需要更多的数据才能获得完整的命令，返回 C_ERR。 * 如果出现协议错误，返回 C_ERR；在这种情况下，客户端结构会被设置为回复错误并关闭连接。 * * 当 processInputBuffer() 检测到下一个命令是 RESP 格式时会调用此函数， * 因为命令的第一个字节是 &#39;*&#39;。否则，对于 inline 命令会调用 processInlineBuffer()。*/ int processMultibulkBuffer(client *c) { char *newline = NULL; int ok; long long ll; if (c-&gt;multibulklen == 0) { /* 客户端应该已经被重置 */ serverAssertWithInfo(c, NULL, c-&gt;argc == 0); /* 多重批量长度不能在没有 \\r\\n 的情况下读取 */ newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\r&#39;); if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big mbulk count string&#34;); setProtocolError(&#34;too big mbulk count string&#34;, c); } return C_ERR; } /* 缓冲区中应也包含 \\n */ if (newline - (c-&gt;querybuf + c-&gt;qb_pos) &gt; (ssize_t)(sdslen(c-&gt;querybuf) - c-&gt;qb_pos - 2)) return C_ERR; /* 确定这是一整行，因为 newline != NULL， * 所以可以继续解析多重批量长度 */ serverAssertWithInfo(c, NULL, c-&gt;querybuf[c-&gt;qb_pos] == &#39;*&#39;); ok = string2ll(c-&gt;querybuf + 1 + c-&gt;qb_pos, newline - (c-&gt;querybuf + 1 + c-&gt;qb_pos), &amp;ll); if (!ok || ll &gt; INT_MAX) { addReplyError(c, &#34;Protocol error: invalid multibulk length&#34;); setProtocolError(&#34;invalid mbulk count&#34;, c); return C_ERR; } else if (ll &gt; 10 &amp;&amp; authRequired(c)) { addReplyError(c, &#34;Protocol error: unauthenticated multibulk length&#34;); setProtocolError(&#34;unauth mbulk count&#34;, c); return C_ERR; } c-&gt;qb_pos = (newline - c-&gt;querybuf) + 2; if (ll &lt;= 0) return C_OK; c-&gt;multibulklen = ll; /* 在客户端结构体中设置 argv 数组。 * 如果空间不足或者需要逐步分配空间，创建新的 argv */ if (unlikely(c-&gt;multibulklen &gt; c-&gt;argv_len || c-&gt;multibulklen &gt; 1024)) { zfree(c-&gt;argv); c-&gt;argv_len = min(c-&gt;multibulklen, 1024); c-&gt;argv = zmalloc(sizeof(robj*) * c-&gt;argv_len); } c-&gt;argv_len_sum = 0; } serverAssertWithInfo(c, NULL, c-&gt;multibulklen &gt; 0); while (c-&gt;multibulklen) { /* 如果未知，读取批量长度 */ if (c-&gt;bulklen == -1) { newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\r&#39;); if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big bulk count string&#34;); setProtocolError(&#34;too big bulk count string&#34;, c); return C_ERR; } break; } /* 缓冲区中也应该包含 \\n */ if (newline - (c-&gt;querybuf + c-&gt;qb_pos) &gt; (ssize_t)(sdslen(c-&gt;querybuf) - c-&gt;qb_pos - 2)) break; if (c-&gt;querybuf[c-&gt;qb_pos] != &#39;$&#39;) { addReplyErrorFormat(c, &#34;Protocol error: expected &#39;$&#39;, got &#39;%c&#39;&#34;, c-&gt;querybuf[c-&gt;qb_pos]); setProtocolError(&#34;expected $ but got something else&#34;, c); return C_ERR; } ok = string2ll(c-&gt;querybuf + c-&gt;qb_pos + 1, newline - (c-&gt;querybuf + c-&gt;qb_pos + 1), &amp;ll); if (!ok || ll &lt; 0 || (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; ll &gt; server.proto_max_bulk_len)) { addReplyError(c, &#34;Protocol error: invalid bulk length&#34;); setProtocolError(&#34;invalid bulk length&#34;, c); return C_ERR; } else if (ll &gt; 16384 &amp;&amp; authRequired(c)) { addReplyError(c, &#34;Protocol error: unauthenticated bulk length&#34;); setProtocolError(&#34;unauth bulk length&#34;, c); return C_ERR; } c-&gt;qb_pos = newline - c-&gt;querybuf + 2; if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; ll &gt;= PROTO_MBULK_BIG_ARG) { /* 如果客户端不是主节点（因为主节点的查询缓冲区只能在数据应用并发送给从节点后修剪）。 * * 如果我们将从网络读取一个较大的对象，尝试使其从 c-&gt;querybuf 边界开始，这样可以优化对象创建， * 避免对数据进行大量复制。 * * 但是只有当未解析的数据长度小于或等于 ll+2 时才这样做。否则，修剪查询缓冲区就是浪费时间， * 因为此时查询缓冲区不仅仅包含我们的大批量数据。 */ if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &lt;= (size_t)ll + 2) { sdsrange(c-&gt;querybuf, c-&gt;qb_pos, -1); c-&gt;qb_pos = 0; /* 提示 sds 库有关字符串长度的预期 */ c-&gt;querybuf = sdsMakeRoomForNonGreedy(c-&gt;querybuf, ll + 2 - sdslen(c-&gt;querybuf)); /* 我们后续会设置峰值为使用的部分，但此时超额分配是为了确保不会在使用前被缩小 */ if (c-&gt;querybuf_peak &lt; (size_t)ll + 2) c-&gt;querybuf_peak = ll + 2; } } c-&gt;bulklen = ll; } /* 读取批量参数 */ if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &lt; (size_t)(c-&gt;bulklen + 2)) { /* 数据不足（+2 是指尾部的 \\r\\n） */ break; } else { /* 检查是否有足够的空间存储参数，如果没有则进行扩展 */ if (c-&gt;argc &gt;= c-&gt;argv_len) { c-&gt;argv_len = min(c-&gt;argv_len &lt; INT_MAX / 2 ? c-&gt;argv_len * 2 : INT_MAX, c-&gt;argc + c-&gt;multibulklen); c-&gt;argv = zrealloc(c-&gt;argv, sizeof(robj*) * c-&gt;argv_len); } /* 优化：如果非主节点客户端的缓冲区仅包含我们的批量元素， * 那么直接使用当前的 sds 字符串而不是通过复制创建一个新的对象 */ if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; c-&gt;qb_pos == 0 &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG &amp;&amp; sdslen(c-&gt;querybuf) == (size_t)(c-&gt;bulklen + 2)) { c-&gt;argv[c-&gt;argc++] = createObject(OBJ_STRING, c-&gt;querybuf); c-&gt;argv_len_sum += c-&gt;bulklen; sdsIncrLen(c-&gt;querybuf, -2); /* 去除 CRLF */ /* 假设如果我们看到一个大的参数，接下来可能会看到另一个类似的 */ c-&gt;querybuf = sdsnewlen(SDS_NOINIT, c-&gt;bulklen + 2); sdsclear(c-&gt;querybuf); } else { c-&gt;argv[c-&gt;argc++] = createStringObject(c-&gt;querybuf + c-&gt;qb_pos, c-&gt;bulklen); c-&gt;argv_len_sum += c-&gt;bulklen; c-&gt;qb_pos += c-&gt;bulklen + 2; } c-&gt;bulklen = -1; c-&gt;multibulklen--; } } /* 当 c-&gt;multibulklen 为 0 时，表示命令处理完成 */ if (c-&gt;multibulklen == 0) return C_OK; /* 仍然没有准备好处理命令 */ return C_ERR; } processCommand处理命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 这个函数调用 processCommand()，同时执行一些对于客户端来说有用的额外任务： * * 1. 将当前客户端设置为 &#39;c&#39;。 * 2. 如果命令已处理，则调用 commandProcessed()。 * * 如果处理命令过程中客户端被释放，则返回 C_ERR，否则返回 C_OK。 */ int processCommandAndResetClient(client *c) { int deadclient = 0; client *old_client = server.current_client; // 设置当前处理的客户端为 &#39;c&#39; server.current_client = c; // 处理命令 if (processCommand(c) == C_OK) { // 如果命令成功处理，调用 commandProcessed() commandProcessed(c); // 更新客户端的内存使用情况，考虑到命令执行后可能导致输出缓冲区的增长 if (c-&gt;conn) updateClientMemUsageAndBucket(c); } // 检查当前客户端是否为空，如果为空表示客户端已经被释放 if (server.current_client == NULL) deadclient = 1; /* * 恢复之前的客户端设置。这个恢复是必要的，因为在脚本超时的情况下， * 我们会从 processEventsWhileBlocked 中进入该代码，这会导致设置 server.current_client。 * 如果不恢复，可能会错误地返回 1，表示客户端已经死掉，并停止从客户端缓冲区读取数据。 */ server.current_client = old_client; // performEvictions 可能会刷新从节点的输出缓冲区，这可能导致 // 从节点（可能是当前活动的客户端）被释放。 return deadclient ? C_ERR : C_OK; } 返回写入的resp给client：initServer -&gt; aeSetBeforeSleepProc -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads -&gt; sendReplyToClient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* 将数据写入客户端的输出缓冲区。如果客户端在调用后仍然有效，返回 C_OK， * 如果因错误而被释放，返回 C_ERR。如果设置了 handler_installed，则会尝试清除写事件。 * * 该函数由线程调用，但总是将 handler_installed 设置为 0。因此，当 handler_installed 设置为 0 时， * 该函数必须是线程安全的。*/ int writeToClient(client *c, int handler_installed) { /* 更新服务器的总写入次数 */ atomicIncr(server.stat_total_writes_processed, 1); ssize_t nwritten = 0, totwritten = 0; /* 循环写入客户端的待处理回复 */ while(clientHasPendingReplies(c)) { int ret = _writeToClient(c, &amp;nwritten); if (ret == C_ERR) break; totwritten += nwritten; /* 注意：我们避免一次写入超过 NET_MAX_WRITES_PER_EVENT 字节。 * 在单线程服务器中，即使来自超高速链接的大请求总是能接受数据， * 也应该服务其他客户端（在实际场景中可以考虑 &#39;KEYS *&#39; 命令通过回环接口）。 * * 然而，如果超出了最大内存限制，我们会忽略此限制，尽可能地发送数据。 * * 此外，如果客户端是从节点或监视器，我们会尽可能多地发送数据， * 否则，在高速流量下，复制/输出缓冲区可能会无限增长。*/ if (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp; (server.maxmemory == 0 || zmalloc_used_memory() &lt; server.maxmemory) &amp;&amp; !(c-&gt;flags &amp; CLIENT_SLAVE)) break; } /* 更新统计信息，记录已经发送的字节数 */ if (unlikely(clientTypeIsSlave(c))) { atomicIncr(server.stat_net_repl_output_bytes, totwritten); } else { atomicIncr(server.stat_net_output_bytes, totwritten); } /* 检查写入是否成功 */ if (nwritten == -1) { if (connGetState(c-&gt;conn) != CONN_STATE_CONNECTED) { serverLog(LL_VERBOSE, &#34;Error writing to client: %s&#34;, connGetLastError(c-&gt;conn)); freeClientAsync(c); return C_ERR; } } /* 如果有数据写入，更新客户端的最后交互时间 */ if (totwritten &gt; 0) { /* 对于表示主节点的客户端，不计算发送数据作为一次交互， * 因为我们总是发送 REPLCONF ACK 命令，这些命令只占用一些时间来填充套接字输出缓冲区。 * 我们仅依赖接收到的数据或 ping 命令来检测超时。 */ if (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime; } /* 如果客户端没有待处理的回复 */ if (!clientHasPendingReplies(c)) { c-&gt;sentlen = 0; /* 请注意，writeToClient() 是在线程中调用的，但 aeDeleteFileEvent() 不是线程安全的： * 然而，由于 writeToClient() 总是在线程中将 handler_installed 设置为 0， * 所以我们可以放心。*/ if (handler_installed) { serverAssert(io_threads_op == IO_THREADS_OP_IDLE); connSetWriteHandler(c-&gt;conn, NULL); } /* 在发送完整回复后关闭连接。 */ if (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) { freeClientAsync(c); return C_ERR; } } /* 在写入数据后更新客户端的内存使用情况。 * 由于这不是线程安全的，所以我们会有条件地执行此操作。 * 如果是多线程写入，则将在 handleClientsWithPendingWritesUsingThreads() 中处理。*/ if (io_threads_op == IO_THREADS_OP_IDLE) updateClientMemUsageAndBucket(c); return C_OK; } 内核函数分析 doc：https://man7.org/linux/man-pages/man7/epoll.7.html\n">
<meta property='og:url' content='http://localhost:1313/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD-reids-%E9%80%9A%E4%BF%A1/'>
<meta property='og:site_name' content='wenxin-blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-11-20T03:44:33&#43;08:00'/><meta property='article:modified_time' content='2024-11-20T03:44:33&#43;08:00'/>
<meta name="twitter:title" content="高性能 reids-通信">
<meta name="twitter:description" content="redis通信 源码分析 系统初始化 &amp; eventloop事件循环总线构建 从main函数说起（原300+行，精简部分非核心内容后包含注释100+行） 网络通信相关主要为：在main函数中启动epoll监听，io多路复用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 int main(int argc, char **argv) { struct timeval tv; int j; char config_from_stdin = 0; /* 系统基础依赖初始化： 1. 时区设置 2. 内存oom处理方法 3. 随机数/哈希种子生成 4. crc64校验码初始化 */ char *exec_name = strrchr(argv[0], &#39;/&#39;); if (exec_name == NULL) exec_name = argv[0]; server.sentinel_mode = checkForSentinelMode(argc,argv, exec_name); initServerConfig(); ACLInit(); /* 初始化 ACL（访问控制列表）系统，网络连接时需要根据ACL控制权限，此时未加载实际配置 */ moduleInitModulesSystem(); connTypeInitialize(); /* 存储可执行文件路径和启动参数，用于以后重启服务器 */ server.executable = getAbsolutePath(argv[0]); server.exec_argv = zmalloc(sizeof(char*)*(argc+1)); server.exec_argv[argc] = NULL; for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]); /* 初始化 Sentinel 相关配置（如果是 Sentinel 模式） */ if (server.sentinel_mode) { initSentinelConfig(); initSentinel(); } /* 检查是否需要启动 redis-check-rdb 或 redis-check-aof 模式 */ if (strstr(exec_name,&#34;redis-check-rdb&#34;) != NULL) redis_check_rdb_main(argc,argv,NULL); else if (strstr(exec_name,&#34;redis-check-aof&#34;) != NULL) redis_check_aof_main(argc,argv); /* 参数解析 */ if (argc &gt;= 2) { j = 1; sds options = sdsempty(); // 使用内部定义的sds字符串结构 /* 解析特殊参数 --version，--help */ if (strcmp(argv[1], &#34;-v&#34;) == 0 || strcmp(argv[1], &#34;--version&#34;) == 0) { sds version = getVersion(); printf(&#34;Redis server %s\\n&#34;, version); sdsfree(version); exit(0); } if (strcmp(argv[1], &#34;--help&#34;) == 0 || strcmp(argv[1], &#34;-h&#34;) == 0) usage(); sds *argv_tmp; int argc_tmp; int handled_last_config_arg = 1; while(j &lt; argc) { /* 遍历解析参数 */ j++; } /* 根据参数完成必要文件配置的加载 */ loadServerConfig(server.configfile, config_from_stdin, options); if (server.sentinel_mode) loadSentinelConfigFromQueue(); sdsfree(options); } if (server.sentinel_mode) sentinelCheckConfigFile(); /* 核心：启动服务 */ initServer(); // 核心中的核心：载入server对象相关的核心组件：signal信号处理器，thread线程管理器，eventloop事件处理总线等 if (background || server.pidfile) createPidFile(); if (server.set_proc_title) redisSetProcTitle(NULL); redisAsciiArt(); // 打印启动redis的ASCII文字 checkTcpBacklogSettings(); if (server.cluster_enabled) { clusterInit(); } if (!server.sentinel_mode) { moduleInitModulesSystemLast(); moduleLoadFromQueue(); } // acl读取实际配置 ACLLoadUsersAtStartup(); initListeners(); if (server.cluster_enabled) { clusterInitLast(); } InitServerLast(); if (!server.sentinel_mode) { // 非sentinel模式 serverLog(LL_NOTICE,&#34;Server initialized&#34;); aofLoadManifestFromDisk(); loadDataFromDisk(); aofOpenIfNeededOnServerStart(); aofDelHistoryFiles(); applyAppendOnlyConfig(); // 集群模式校验 if (server.cluster_enabled) { serverAssert(verifyClusterConfigWithData() == C_OK); } // 打印所有监听器的状态 for (j = 0; j &lt; CONN_TYPE_MAX; j++) { connListener *listener = &amp;server.listeners[j]; if (listener-&gt;ct == NULL) continue; serverLog(LL_NOTICE,&#34;Ready to accept connections %s&#34;, listener-&gt;ct-&gt;get_type(NULL)); } if (server.supervised_mode == SUPERVISED_SYSTEMD) { // 如果是由 systemd 监督运行的 Redis 实例，通知 systemd Redis 状态 } } else { sentinelIsRunning(); if (server.supervised_mode == SUPERVISED_SYSTEMD) { // 如果是由 systemd 监督运行的 sentinel 实例，通知 systemd sentinel 状态 } } /* 内存分配过小（1MB）警告 */ if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) { serverLog(LL_WARNING,&#34;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&#34;, server.maxmemory); } redisSetCpuAffinity(server.server_cpulist); setOOMScoreAdj(-1); // epoll监听，io多路复用，死循环 aeMain(server.el); aeDeleteEventLoop(server.el); return 0; } 核心中的核心：initServer方法，载入server对象相关的核心组件：signal信号处理器，thread线程管理器，eventloop事件处理总线等。（原200+行，精简部分非核心内容后包含注释60+行） 网络通信相关主要为：在初始化函数中创建thread线程管理器，eventloop事件处理总线 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 void initServer(void) { // 信号处理器，例如ctrl+c发送SIGKILL信号，此时需要关闭服务 setupSignalHandlers(); // 线程管理器初始化 ThreadsManager_init(); makeThreadKillable(); /* 在从配置系统设置默认值后进行初始化 */ server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF; server.fsynced_reploff = server.aof_enabled ? 0 : -1; server.hz = server.config_hz; // 心跳频率 server.pid = getpid(); // 创建eventloop事件处理总线，基于epoll机制（linux） server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR); if (server.el == NULL) { serverLog(LL_WARNING, &#34;Failed creating the event loop. Error message: &#39;%s&#39;&#34;, strerror(errno)); exit(1); } /* 创建定时器回调，这是我们处理许多后台操作的方式， 比如客户端超时、未访问的过期键的淘汰等 */ if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) { serverPanic(&#34;Can&#39;t create event loop timers.&#34;); exit(1); } /* 为用于唤醒事件循环的管道注册一个可读事件， 用于模块线程间的通信 */ if (aeCreateFileEvent(server.el, server.module_pipe[0], AE_READABLE, modulePipeReadable,NULL) == AE_ERR) { serverPanic( &#34;Error registering the readable event for the module pipe.&#34;); } /* 注册epoll阻塞前后的回调函数（需在加载持久化之前完成，因为它会被 processEventsWhileBlocked 使用） */ aeSetBeforeSleepProc(server.el,beforeSleep); aeSetAfterSleepProc(server.el,afterSleep); /* 32位老系统受限于寻址上限32bit，最多访问2^32个字节，也就是4294967296B -&gt; 4GB，redis会默认限制3GB上限 */ if (server.arch_bits == 32 &amp;&amp; server.maxmemory == 0) { serverLog(LL_WARNING,&#34;Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with &#39;noeviction&#39; policy now.&#34;); server.maxmemory = 3072LL*(1024*1024); /* 3 GB */ server.maxmemory_policy = MAXMEMORY_NO_EVICTION; } // 脚本系统初始化 luaEnvInit(); scriptingInit(1); if (functionsInit() == C_ERR) { serverPanic(&#34;Functions initialization failed, check the server logs.&#34;); exit(1); } // 基本监控初始化：提供慢查询告警/延迟监控等功能 slowlogInit(); latencyMonitorInit(); // 参照配置初始化密码，一般不启用 ACLUpdateDefaultUserPassword(server.requirepass); // 定时器功能初始化 applyWatchdogPeriod(); if (server.maxmemory_clients != 0) initServerClientMemUsageBuckets(); } aeCreateEventLoop方法：创建事件循环总线 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 aeEventLoop *aeCreateEventLoop(int setsize) { aeEventLoop *eventLoop; monotonicInit(); /* just in case the calling app didn&#39;t initialize */ // 分配内存：最大感兴趣的fd为setsize if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err; eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize); eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize); if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err; eventLoop-&gt;setsize = setsize; eventLoop-&gt;timeEventHead = NULL; eventLoop-&gt;timeEventNextId = 0; eventLoop-&gt;stop = 0; eventLoop-&gt;maxfd = -1; eventLoop-&gt;beforesleep = NULL; eventLoop-&gt;aftersleep = NULL; eventLoop-&gt;flags = 0; if (aeApiCreate(eventLoop) == -1) goto err; // 核心：调用封装的函数aeApiCreate /* Events的关注事件默认置为0（不关注任何事件）*/ for (int i = 0; i &lt; setsize; i++) eventLoop-&gt;events[i].mask = AE_NONE; return eventLoop; err: // 失败则释放内存 if (eventLoop) { zfree(eventLoop-&gt;events); zfree(eventLoop-&gt;fired); zfree(eventLoop); } return NULL; } /* ae_epoll.c，仅在上面代码中调用，创建事件总线\t这里依赖系统内置库函数：epoll_create，其中size参数仅为参考值，对较新的linux版本来说无实际作用 */ static int aeApiCreate(aeEventLoop *eventLoop) { aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize); if (!state-&gt;events) { zfree(state); return -1; } state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */ if (state-&gt;epfd == -1) { zfree(state-&gt;events); zfree(state); return -1; } anetCloexec(state-&gt;epfd); eventLoop-&gt;apidata = state; return 0; } ae_epoll.c封装系统库函数（无精简） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 #include &lt;sys/epoll.h&gt; typedef struct aeApiState { int epfd; struct epoll_event *events; } aeApiState; /* 仅在aeCreateEventLoop代码中调用，创建事件总线\t依赖系统内置库函数：epoll_create，其中： size参数仅为参考值，对较新的linux版本来说无实际作用 */ static int aeApiCreate(aeEventLoop *eventLoop) { aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize); if (!state-&gt;events) { zfree(state); return -1; } state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */ if (state-&gt;epfd == -1) { zfree(state-&gt;events); zfree(state); return -1; } anetCloexec(state-&gt;epfd); eventLoop-&gt;apidata = state; return 0; } // resize event数组，类似vector(c)/list(java)/slice(golang/python)动态扩容 static int aeApiResize(aeEventLoop *eventLoop, int setsize) { aeApiState *state = eventLoop-&gt;apidata; state-&gt;events = zrealloc(state-&gt;events, sizeof(struct epoll_event)*setsize); return 0; } // 释放资源 static void aeApiFree(aeEventLoop *eventLoop) { aeApiState *state = eventLoop-&gt;apidata; close(state-&gt;epfd); zfree(state-&gt;events); zfree(state); } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_ctl，其中： epfd为事件总线fd， op为注册操作，枚举EPOLL_CTL_ADD, EPOLL_CTL_ADD, EPOLL_CTL_DEL， fd为注册的新fd， ee为新建的epoll_event结构体实例 */ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) { aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee = {0}; /* avoid valgrind warning */ /* If the fd was already monitored for some event, we need a MOD * operation. Otherwise we need an ADD operation. */ int op = eventLoop-&gt;events[fd].mask == AE_NONE ? EPOLL_CTL_ADD : EPOLL_CTL_MOD; ee.events = 0; mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */ if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.fd = fd; if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1; return 0; } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_ctl，其中： epfd为事件总线fd， op为注册操作，枚举EPOLL_CTL_ADD, EPOLL_CTL_ADD, EPOLL_CTL_DEL， fd为注册的新fd， ee为新建的epoll_event结构体实例，关注的mask写在这个结构体中 */ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) { aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee = {0}; /* avoid valgrind warning */ int mask = eventLoop-&gt;events[fd].mask &amp; (~delmask); ee.events = 0; if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.fd = fd; if (mask != AE_NONE) { epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee); } else { /* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for * EPOLL_CTL_DEL. */ epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee); } } /* 在eventloop中注册新的fd，mask为感兴趣的事件 依赖系统内置库函数epoll_wait，其中： epfd为事件总线fd， events为已注册的全部感兴趣事件， tvp相关为等待时间，-1为一直阻塞，直到有注册的感兴趣事件发生 */ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) { aeApiState *state = eventLoop-&gt;apidata; int retval, numevents = 0; retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize, tvp ? (tvp-&gt;tv_sec*1000 + (tvp-&gt;tv_usec + 999)/1000) : -1); if (retval &gt; 0) { int j; numevents = retval; for (j = 0; j &lt; numevents; j++) { int mask = 0; struct epoll_event *e = state-&gt;events+j; if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE; if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE; if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE|AE_READABLE; if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE; eventLoop-&gt;fired[j].fd = e-&gt;data.fd; eventLoop-&gt;fired[j].mask = mask; } } else if (retval == -1 &amp;&amp; errno != EINTR) { panic(&#34;aeApiPoll: epoll_wait, %s&#34;, strerror(errno)); } return numevents; } static char *aeApiName(void) { return &#34;epoll&#34;; } 哪些地方调用了注册事件 server启动过程中：initListeners -&gt; createSocketAcceptHandler （accept） connSocketAcceptHandler 创建客户端连接时：ConnectionType -&gt; connSocketConnect（connect） ae_handler -&gt; connSocketSetReadHandler 建立client通信时：createClient -&gt; readQueryFromClient ae_handler -&gt; connSocketSetWriteHandler 初始化服务端时：initServer -&gt; aeSetBeforeSleepProc -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads -&gt; sendReplyToClient 同步rdb数据：initServer -&gt; aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) -&gt; serverCron -&gt; checkChildrenDone -&gt; replicationStartPendingFork -&gt; rdbSaveToSlavesSockets rdbPipeReadHandler sentinel通信：initServer -&gt; aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) -&gt; serverCron -&gt; sentinelTimer -&gt; sentinelHandleDictOfRedisInstances -&gt; sentinelHandleRedisInstance -&gt; sentinelReconnectInstance -&gt; redisAeAttach -&gt; redisAeAddWrite pipeline管道的bio通信：initServer -&gt; InitServerLast -&gt; bioInit 注册事件处理：main -&gt; aeMain -&gt; aeApiPoll -&gt; epoll_wait 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 // 死循环处理事件 void aeMain(aeEventLoop *eventLoop) { eventLoop-&gt;stop = 0; while (!eventLoop-&gt;stop) { aeProcessEvents(eventLoop, AE_ALL_EVENTS| AE_CALL_BEFORE_SLEEP| AE_CALL_AFTER_SLEEP); } } typedef struct aeEventLoop { int maxfd; /* highest file descriptor currently registered */ int setsize; /* max number of file descriptors tracked */ long long timeEventNextId; aeFileEvent *events; /* Registered events */ aeFiredEvent *fired; /* Fired events */ aeTimeEvent *timeEventHead; int stop; void *apidata; /* This is used for polling API specific data */ aeBeforeSleepProc *beforesleep; aeBeforeSleepProc *aftersleep; int flags; } aeEventLoop; typedef struct aeFileEvent { int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */ aeFileProc *rfileProc; aeFileProc *wfileProc; void *clientData; } aeFileEvent; int aeProcessEvents(aeEventLoop *eventLoop, int flags) { int processed = 0, numevents; /* 如果没有文件事件和时间事件需要处理，直接返回 */ if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0; /* 即使没有文件事件，如果有时间事件，也需要调用 aeApiPoll 来等待下一次时间事件的触发 */ if (eventLoop-&gt;maxfd != -1 || ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) { int j; struct timeval tv, *tvp = NULL; /* NULL means infinite wait. */ int64_t usUntilTimer; if (eventLoop-&gt;beforesleep != NULL &amp;&amp; (flags &amp; AE_CALL_BEFORE_SLEEP)) /* Before sleep callback. */ eventLoop-&gt;beforesleep(eventLoop); /* eventLoop-&gt;flags 可能会在 beforeSleep 中发生改变，所以需要在调用 beforeSleep 后重新检查 同时，flags 参数优先级更高，特别是 AE_DONT_WAIT 设置时，应忽略 eventLoop-&gt;flags 中的值 */ if ((flags &amp; AE_DONT_WAIT) || (eventLoop-&gt;flags &amp; AE_DONT_WAIT)) { tv.tv_sec = tv.tv_usec = 0; tvp = &amp;tv; } else if (flags &amp; AE_TIME_EVENTS) { usUntilTimer = usUntilEarliestTimer(eventLoop); if (usUntilTimer &gt;= 0) { tv.tv_sec = usUntilTimer / 1000000; tv.tv_usec = usUntilTimer % 1000000; tvp = &amp;tv; } } /* 调用aeApiPoll多路复用方法，Call the multiplexing API, will return only on timeout or when some event fires. */ numevents = aeApiPoll(eventLoop, tvp); /* 如果没有请求处理文件事件，就跳过文件事件的处理 */ if (!(flags &amp; AE_FILE_EVENTS)) { numevents = 0; } /* After sleep callback. */ if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP) eventLoop-&gt;aftersleep(eventLoop); for (j = 0; j &lt; numevents; j++) { int fd = eventLoop-&gt;fired[j].fd; aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; int mask = eventLoop-&gt;fired[j].mask; int fired = 0; /* Number of events fired for current fd. */ /* 默认情况下，先执行可读事件，再执行可写事件。这个顺序可以确保有可读数据时，优先处理读取请求。 * 如果设置了 AE_BARRIER 标志，则表示我们希望反转执行顺序，先执行可写事件。 */ int invert = fe-&gt;mask &amp; AE_BARRIER; /* 检查事件是否仍然有效：可能已经处理过的事件在当前回合中已经被移除 */ if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) { fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */ } /* 执行可写事件 */ if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) { if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) { fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; } } /* 如果需要反转执行顺序，在可写事件后执行可读事件 */ if (invert) { fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */ if ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp; (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) { fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; } } processed++; } } /* 如果需要处理时间事件，则继续处理时间事件 */ if (flags &amp; AE_TIME_EVENTS) processed += processTimeEvents(eventLoop); return processed; } 多路复用处理方法（类似netty中的handler实现） 协议解析：createClient -&gt; readQueryFromClient -&gt; processInputBuffer -&gt; processXXXBuffer -&gt; processCommandAndResetClient inline：processInlineBuffer multi：processMultibulkBuffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 void readQueryFromClient(connection *conn) { client *c = connGetPrivateData(conn); int nread, big_arg = 0; size_t qblen, readlen; /* 如果启用了线程化 I/O，并且需要在退出事件循环时稍后读取客户端数据 */ if (postponeClientRead(c)) return; /* 更新服务器的总读取次数 */ atomicIncr(server.stat_total_reads_processed, 1); readlen = PROTO_IOBUF_LEN; /* 如果这是一个多批量请求，并且正在处理一个较大的批量回复，尽量确保查询缓冲区 * 精确包含表示对象的 SDS 字符串，即使这可能会导致更多的 read(2) 调用。 * 这样，函数 processMultiBulkBuffer() 可以避免复制缓冲区来创建 Redis 对象。 */ if (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != -1 &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG) { /* 对于大的参数，客户端总是使用其私有的查询缓冲区。 * 使用可重用的查询缓冲区可能会导致其超出 32k，最终让客户端接管这个缓冲区。 */ if (!c-&gt;querybuf) c-&gt;querybuf = sdsempty(); ssize_t remaining = (size_t)(c-&gt;bulklen+2)-(sdslen(c-&gt;querybuf)-c-&gt;qb_pos); big_arg = 1; /* 注意：&#39;remaining&#39; 变量在某些边缘情况下可能为零，例如当在 CLIENT PAUSE 后恢复被阻塞的客户端时 */ if (remaining &gt; 0) readlen = remaining; /* 如果是主客户端，在遇到大参数时需要扩大读取长度，但不需要对齐到下一个参数，可以读取更多数据 */ if (c-&gt;flags &amp; CLIENT_MASTER &amp;&amp; readlen &lt; PROTO_IOBUF_LEN) readlen = PROTO_IOBUF_LEN; } else if (c-&gt;querybuf == NULL) { if (unlikely(thread_reusable_qb_used)) { /* 如果可重用的查询缓冲区已被其他客户端使用，切换到使用客户端的私有查询缓冲区。 * 这种情况仅在通过 processEventsWhileBlocked() 执行嵌套命令时发生。 */ c-&gt;querybuf = sdsnewlen(NULL, PROTO_IOBUF_LEN); sdsclear(c-&gt;querybuf); } else { /* 如果查询缓冲区不存在，则创建可重用的查询缓冲区 */ if (!thread_reusable_qb) { thread_reusable_qb = sdsnewlen(NULL, PROTO_IOBUF_LEN); sdsclear(thread_reusable_qb); } /* 将可重用的查询缓冲区分配给客户端，并标记为正在使用 */ serverAssert(sdslen(thread_reusable_qb) == 0); c-&gt;querybuf = thread_reusable_qb; c-&gt;flags |= CLIENT_REUSABLE_QUERYBUFFER; thread_reusable_qb_used = 1; } } qblen = sdslen(c-&gt;querybuf); if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; // 主客户端的查询缓冲区可以贪婪扩展 (big_arg || sdsalloc(c-&gt;querybuf) &lt; PROTO_IOBUF_LEN)) { /* 在读取大参数时，我们不会读取超过一个参数的内容到查询缓冲区， * 所以不需要预分配多于所需的空间，因此使用非贪婪扩展。 */ c-&gt;querybuf = sdsMakeRoomForNonGreedy(c-&gt;querybuf, readlen); /* 稍后将峰值设置为已使用的部分，但这里我们过度分配，因为我们知道需要的空间，确保在使用前不会被缩小。 */ if (c-&gt;querybuf_peak &lt; qblen + readlen) c-&gt;querybuf_peak = qblen + readlen; } else { c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); /* 从套接字中尽可能多地读取数据，以节省 read(2) 系统调用次数。 */ readlen = sdsavail(c-&gt;querybuf); } nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen); if (nread == -1) { if (connGetState(conn) == CONN_STATE_CONNECTED) { goto done; } else { serverLog(LL_VERBOSE, &#34;从客户端读取数据时出错: %s&#34;, connGetLastError(c-&gt;conn)); freeClientAsync(c); goto done; } } else if (nread == 0) { if (server.verbosity &lt;= LL_VERBOSE) { sds info = catClientInfoString(sdsempty(), c); serverLog(LL_VERBOSE, &#34;客户端关闭了连接 %s&#34;, info); sdsfree(info); } freeClientAsync(c); goto done; } /* 更新查询缓冲区的长度 */ sdsIncrLen(c-&gt;querybuf, nread); qblen = sdslen(c-&gt;querybuf); if (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen; /* 更新最后交互时间 */ c-&gt;lastinteraction = server.unixtime; if (c-&gt;flags &amp; CLIENT_MASTER) { c-&gt;read_reploff += nread; atomicIncr(server.stat_net_repl_input_bytes, nread); } else { atomicIncr(server.stat_net_input_bytes, nread); } /* 对于普通客户端，如果查询缓冲区的大小超过限制或需要身份验证，则关闭客户端连接 */ if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; /* MULTI/EXEC 队列中的命令尚未执行，因此它们也算作查询缓冲区的一部分 */ (c-&gt;mstate.argv_len_sums + sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len || (c-&gt;mstate.argv_len_sums + sdslen(c-&gt;querybuf) &gt; 1024*1024 &amp;&amp; authRequired(c)))) { sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty(); bytes = sdscatrepr(bytes,c-&gt;querybuf,64); serverLog(LL_WARNING,&#34;关闭客户端，查询缓冲区超过最大限制: %s (查询缓冲区初始字节: %s)&#34;, ci, bytes); sdsfree(ci); sdsfree(bytes); freeClientAsync(c); atomicIncr(server.stat_client_qbuf_limit_disconnections, 1); goto done; } /* 如果客户端输入缓冲区还有数据，继续解析并检查是否有完整的命令需要执行 */ if (processInputBuffer(c) == C_ERR) c = NULL; done: if (c &amp;&amp; (c-&gt;flags &amp; CLIENT_REUSABLE_QUERYBUFFER)) { serverAssert(c-&gt;qb_pos == 0); /* 确保客户端的查询缓冲区在 processInputBuffer 中被修剪 */ resetReusableQueryBuf(c); } beforeNextClient(c); } processInputBuffer读取client请求信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* 该函数在每次客户端结构体 &#39;c&#39; 中有更多查询缓冲区需要处理时被调用， * 可能是因为我们从套接字读取了更多的数据，或者客户端被阻塞并在之后重新激活， * 所以可能存在待处理的查询缓冲区，这些缓冲区可能已经代表一个完整的命令需要处理。 * 如果在处理过程中客户端已经被释放，则返回 C_ERR */ int processInputBuffer(client *c) { /* 当输入缓冲区有内容时，继续处理 */ while(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) { /* 如果客户端当前被阻塞，立即中止 */ if (c-&gt;flags &amp; CLIENT_BLOCKED) break; /* 如果客户端有待处理的命令，不要继续处理更多的缓冲区 */ if (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) break; /* 如果客户端是主客户端，并且当前有忙碌脚本，暂停处理输入 */ if (isInsideYieldingLongCommand() &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) break; /* 如果设置了 CLIENT_CLOSE_AFTER_REPLY 标志，处理完回复后就关闭连接， * 不允许继续处理更多的命令 */ if (c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break; /* 如果请求类型未知，判断请求类型 */ if (!c-&gt;reqtype) { if (c-&gt;querybuf[c-&gt;qb_pos] == &#39;*&#39;) { c-&gt;reqtype = PROTO_REQ_MULTIBULK; // 多批量请求 } else { c-&gt;reqtype = PROTO_REQ_INLINE; // 单行命令 } } /* 根据请求类型处理缓冲区 */ if (c-&gt;reqtype == PROTO_REQ_INLINE) { if (processInlineBuffer(c) != C_OK) break; // 处理单行命令 } else if (c-&gt;reqtype == PROTO_REQ_MULTIBULK) { if (processMultibulkBuffer(c) != C_OK) break; // 处理多批量命令 } else { serverPanic(&#34;Unknown request type&#34;); // 未知的请求类型，程序崩溃 } /* 多批量请求处理可能导致 argc &lt;= 0 */ if (c-&gt;argc == 0) { resetClientInternal(c, 0); // 如果没有有效的参数，重置客户端 } else { /* 如果是 I/O 线程上下文，不能在此执行命令，只能标记客户端需要处理命令 */ if (io_threads_op != IO_THREADS_OP_IDLE) { serverAssert(io_threads_op == IO_THREADS_OP_READ); c-&gt;flags |= CLIENT_PENDING_COMMAND; // 设置为待处理命令状态 break; } /* 准备好执行命令了 */ if (processCommandAndResetClient(c) == C_ERR) { /* 如果客户端已经不再有效，避免继续执行，直接返回 */ return C_ERR; } } } /* 如果客户端是主客户端，需要裁剪查询缓冲区 */ if (c-&gt;flags &amp; CLIENT_MASTER) { /* 如果客户端是主客户端，裁剪查询缓冲区到 repl_applied 指定的位置， * 因为主客户端的查询缓冲区不仅用于解析命令，还用于代理给子复制实例。 * * 需要裁剪查询缓冲区的场景： * 1. 没有接收到完整的命令 * 2. 主客户端因为客户端暂停而被阻塞 * 3. I/O 线程操作读取，主客户端被标记为 CLIENT_PENDING_COMMAND * * 在这些场景下，qb_pos 指向当前命令的一部分或下一个命令的开始位置， * 当前命令尚未应用，因此 repl_applied 不等于 qb_pos。*/ if (c-&gt;repl_applied) { sdsrange(c-&gt;querybuf, c-&gt;repl_applied, -1); // 剩余的命令数据 c-&gt;qb_pos -= c-&gt;repl_applied; c-&gt;repl_applied = 0; } } else if (c-&gt;qb_pos) { /* 如果客户端不是主客户端，裁剪查询缓冲区 */ sdsrange(c-&gt;querybuf, c-&gt;qb_pos, -1); // 将查询缓冲区裁剪到当前位置 c-&gt;qb_pos = 0; // 重置查询缓冲区位置 } /* 在处理查询缓冲区后更新客户端的内存使用情况， * 这对查询缓冲区比较大且没有在上述循环中被完全处理的客户端很重要（ * 例如部分发送的大命令）。*/ if (io_threads_op == IO_THREADS_OP_IDLE) updateClientMemUsageAndBucket(c); return C_OK; // 返回处理成功 } 协议解析 processInlineBuffer：set a b这样的简单命令 processMultibulkBuffer：mset a b c d这样的复合命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 /* 类似于 processMultibulkBuffer()，但是用于处理 inline 协议，而不是 RESP 协议。 * 该函数消耗客户端的查询缓冲区，并在客户端结构体中创建一个准备执行的命令。 * 如果命令已经准备好执行，则返回 C_OK；如果仍然需要读取更多协议数据才能形成一个有效的命令，则返回 C_ERR。 * 当出现协议错误时，返回 C_ERR；在这种情况下，客户端结构体会被设置为回复错误并关闭连接。 */ int processInlineBuffer(client *c) { char *newline; int argc, j, linefeed_chars = 1; sds *argv, aux; size_t querylen; /* 查找换行符的位置 */ newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\n&#39;); /* 如果没有找到 \\r\\n 则返回，不做处理 */ if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big inline request&#34;); setProtocolError(&#34;too big inline request&#34;, c); } return C_ERR; } /* 处理 \\r\\n 的情况 */ if (newline != c-&gt;querybuf + c-&gt;qb_pos &amp;&amp; *(newline - 1) == &#39;\\r&#39;) { newline--; // 将 newline 指向 \\r 的前一个字符 linefeed_chars++; // 计算换行符的字符数 } /* 截取从当前指针到 \\r\\n 之间的内容 */ querylen = newline - (c-&gt;querybuf + c-&gt;qb_pos); aux = sdsnewlen(c-&gt;querybuf + c-&gt;qb_pos, querylen); // 创建一个新的 sds 字符串 argv = sdssplitargs(aux, &amp;argc); // 分割命令行参数 sdsfree(aux); // 释放临时变量 aux if (argv == NULL) { addReplyError(c, &#34;Protocol error: unbalanced quotes in request&#34;); setProtocolError(&#34;unbalanced quotes in inline request&#34;, c); return C_ERR; } /* 如果查询长度为 0 且客户端是从属节点， * 则表示通过换行符刷新最后的 ACK 时间。 * 这是为了让从属节点在加载大型 RDB 文件时能够持续保持连接 */ if (querylen == 0 &amp;&amp; clientTypeIsSlave(c)) { c-&gt;repl_ack_time = server.unixtime; } /* 主节点不应该发送 inline 协议来执行实际的命令。 * 如果发生这种情况，可能是 Redis 协议出现了同步问题， * 比如由于 PSYNC 出错导致的协议不一致。 * * 但是有一个例外：主节点可能只会发送一个换行符来保持连接活动。 */ if (querylen != 0 &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) { sdsfreesplitres(argv, argc); // 释放参数数组 serverLog(LL_WARNING, &#34;WARNING: Receiving inline protocol from master, master stream corruption? Closing the master connection and discarding the cached master.&#34;); setProtocolError(&#34;Master using the inline protocol. Desync?&#34;, c); return C_ERR; } /* 移动查询缓冲区位置，指向下一个查询命令 */ c-&gt;qb_pos += querylen + linefeed_chars; /* 在客户端结构体中设置 argv 数组 */ if (argc) { /* 如果参数数量超过当前分配的空间，重新分配内存 */ if (unlikely(argc &gt; c-&gt;argv_len)) { zfree(c-&gt;argv); // 释放旧的 argv c-&gt;argv = zmalloc(sizeof(robj*) * argc); // 分配新的 argv 数组 c-&gt;argv_len = argc; } c-&gt;argv_len_sum = 0; // 重置参数长度总和 } /* 为所有的参数创建 Redis 对象 */ for (c-&gt;argc = 0, j = 0; j &lt; argc; j++) { c-&gt;argv[c-&gt;argc] = createObject(OBJ_STRING, argv[j]); // 创建字符串类型的 Redis 对象 c-&gt;argc++; // 增加参数计数 c-&gt;argv_len_sum += sdslen(argv[j]); // 更新参数总长度 } zfree(argv); // 释放临时分割后的参数数组 return C_OK; // 返回命令已准备好执行 } /* 处理客户端 &#39;c&#39; 的查询缓冲区，并为命令执行设置客户端的参数向量。 * 如果客户端有一个格式正确、准备执行的命令，返回 C_OK， * 否则，如果还需要更多的数据才能获得完整的命令，返回 C_ERR。 * 如果出现协议错误，返回 C_ERR；在这种情况下，客户端结构会被设置为回复错误并关闭连接。 * * 当 processInputBuffer() 检测到下一个命令是 RESP 格式时会调用此函数， * 因为命令的第一个字节是 &#39;*&#39;。否则，对于 inline 命令会调用 processInlineBuffer()。*/ int processMultibulkBuffer(client *c) { char *newline = NULL; int ok; long long ll; if (c-&gt;multibulklen == 0) { /* 客户端应该已经被重置 */ serverAssertWithInfo(c, NULL, c-&gt;argc == 0); /* 多重批量长度不能在没有 \\r\\n 的情况下读取 */ newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\r&#39;); if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big mbulk count string&#34;); setProtocolError(&#34;too big mbulk count string&#34;, c); } return C_ERR; } /* 缓冲区中应也包含 \\n */ if (newline - (c-&gt;querybuf + c-&gt;qb_pos) &gt; (ssize_t)(sdslen(c-&gt;querybuf) - c-&gt;qb_pos - 2)) return C_ERR; /* 确定这是一整行，因为 newline != NULL， * 所以可以继续解析多重批量长度 */ serverAssertWithInfo(c, NULL, c-&gt;querybuf[c-&gt;qb_pos] == &#39;*&#39;); ok = string2ll(c-&gt;querybuf + 1 + c-&gt;qb_pos, newline - (c-&gt;querybuf + 1 + c-&gt;qb_pos), &amp;ll); if (!ok || ll &gt; INT_MAX) { addReplyError(c, &#34;Protocol error: invalid multibulk length&#34;); setProtocolError(&#34;invalid mbulk count&#34;, c); return C_ERR; } else if (ll &gt; 10 &amp;&amp; authRequired(c)) { addReplyError(c, &#34;Protocol error: unauthenticated multibulk length&#34;); setProtocolError(&#34;unauth mbulk count&#34;, c); return C_ERR; } c-&gt;qb_pos = (newline - c-&gt;querybuf) + 2; if (ll &lt;= 0) return C_OK; c-&gt;multibulklen = ll; /* 在客户端结构体中设置 argv 数组。 * 如果空间不足或者需要逐步分配空间，创建新的 argv */ if (unlikely(c-&gt;multibulklen &gt; c-&gt;argv_len || c-&gt;multibulklen &gt; 1024)) { zfree(c-&gt;argv); c-&gt;argv_len = min(c-&gt;multibulklen, 1024); c-&gt;argv = zmalloc(sizeof(robj*) * c-&gt;argv_len); } c-&gt;argv_len_sum = 0; } serverAssertWithInfo(c, NULL, c-&gt;multibulklen &gt; 0); while (c-&gt;multibulklen) { /* 如果未知，读取批量长度 */ if (c-&gt;bulklen == -1) { newline = strchr(c-&gt;querybuf + c-&gt;qb_pos, &#39;\\r&#39;); if (newline == NULL) { if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) { addReplyError(c, &#34;Protocol error: too big bulk count string&#34;); setProtocolError(&#34;too big bulk count string&#34;, c); return C_ERR; } break; } /* 缓冲区中也应该包含 \\n */ if (newline - (c-&gt;querybuf + c-&gt;qb_pos) &gt; (ssize_t)(sdslen(c-&gt;querybuf) - c-&gt;qb_pos - 2)) break; if (c-&gt;querybuf[c-&gt;qb_pos] != &#39;$&#39;) { addReplyErrorFormat(c, &#34;Protocol error: expected &#39;$&#39;, got &#39;%c&#39;&#34;, c-&gt;querybuf[c-&gt;qb_pos]); setProtocolError(&#34;expected $ but got something else&#34;, c); return C_ERR; } ok = string2ll(c-&gt;querybuf + c-&gt;qb_pos + 1, newline - (c-&gt;querybuf + c-&gt;qb_pos + 1), &amp;ll); if (!ok || ll &lt; 0 || (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; ll &gt; server.proto_max_bulk_len)) { addReplyError(c, &#34;Protocol error: invalid bulk length&#34;); setProtocolError(&#34;invalid bulk length&#34;, c); return C_ERR; } else if (ll &gt; 16384 &amp;&amp; authRequired(c)) { addReplyError(c, &#34;Protocol error: unauthenticated bulk length&#34;); setProtocolError(&#34;unauth bulk length&#34;, c); return C_ERR; } c-&gt;qb_pos = newline - c-&gt;querybuf + 2; if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; ll &gt;= PROTO_MBULK_BIG_ARG) { /* 如果客户端不是主节点（因为主节点的查询缓冲区只能在数据应用并发送给从节点后修剪）。 * * 如果我们将从网络读取一个较大的对象，尝试使其从 c-&gt;querybuf 边界开始，这样可以优化对象创建， * 避免对数据进行大量复制。 * * 但是只有当未解析的数据长度小于或等于 ll+2 时才这样做。否则，修剪查询缓冲区就是浪费时间， * 因为此时查询缓冲区不仅仅包含我们的大批量数据。 */ if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &lt;= (size_t)ll + 2) { sdsrange(c-&gt;querybuf, c-&gt;qb_pos, -1); c-&gt;qb_pos = 0; /* 提示 sds 库有关字符串长度的预期 */ c-&gt;querybuf = sdsMakeRoomForNonGreedy(c-&gt;querybuf, ll + 2 - sdslen(c-&gt;querybuf)); /* 我们后续会设置峰值为使用的部分，但此时超额分配是为了确保不会在使用前被缩小 */ if (c-&gt;querybuf_peak &lt; (size_t)ll + 2) c-&gt;querybuf_peak = ll + 2; } } c-&gt;bulklen = ll; } /* 读取批量参数 */ if (sdslen(c-&gt;querybuf) - c-&gt;qb_pos &lt; (size_t)(c-&gt;bulklen + 2)) { /* 数据不足（+2 是指尾部的 \\r\\n） */ break; } else { /* 检查是否有足够的空间存储参数，如果没有则进行扩展 */ if (c-&gt;argc &gt;= c-&gt;argv_len) { c-&gt;argv_len = min(c-&gt;argv_len &lt; INT_MAX / 2 ? c-&gt;argv_len * 2 : INT_MAX, c-&gt;argc + c-&gt;multibulklen); c-&gt;argv = zrealloc(c-&gt;argv, sizeof(robj*) * c-&gt;argv_len); } /* 优化：如果非主节点客户端的缓冲区仅包含我们的批量元素， * 那么直接使用当前的 sds 字符串而不是通过复制创建一个新的对象 */ if (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; c-&gt;qb_pos == 0 &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG &amp;&amp; sdslen(c-&gt;querybuf) == (size_t)(c-&gt;bulklen + 2)) { c-&gt;argv[c-&gt;argc++] = createObject(OBJ_STRING, c-&gt;querybuf); c-&gt;argv_len_sum += c-&gt;bulklen; sdsIncrLen(c-&gt;querybuf, -2); /* 去除 CRLF */ /* 假设如果我们看到一个大的参数，接下来可能会看到另一个类似的 */ c-&gt;querybuf = sdsnewlen(SDS_NOINIT, c-&gt;bulklen + 2); sdsclear(c-&gt;querybuf); } else { c-&gt;argv[c-&gt;argc++] = createStringObject(c-&gt;querybuf + c-&gt;qb_pos, c-&gt;bulklen); c-&gt;argv_len_sum += c-&gt;bulklen; c-&gt;qb_pos += c-&gt;bulklen + 2; } c-&gt;bulklen = -1; c-&gt;multibulklen--; } } /* 当 c-&gt;multibulklen 为 0 时，表示命令处理完成 */ if (c-&gt;multibulklen == 0) return C_OK; /* 仍然没有准备好处理命令 */ return C_ERR; } processCommand处理命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 这个函数调用 processCommand()，同时执行一些对于客户端来说有用的额外任务： * * 1. 将当前客户端设置为 &#39;c&#39;。 * 2. 如果命令已处理，则调用 commandProcessed()。 * * 如果处理命令过程中客户端被释放，则返回 C_ERR，否则返回 C_OK。 */ int processCommandAndResetClient(client *c) { int deadclient = 0; client *old_client = server.current_client; // 设置当前处理的客户端为 &#39;c&#39; server.current_client = c; // 处理命令 if (processCommand(c) == C_OK) { // 如果命令成功处理，调用 commandProcessed() commandProcessed(c); // 更新客户端的内存使用情况，考虑到命令执行后可能导致输出缓冲区的增长 if (c-&gt;conn) updateClientMemUsageAndBucket(c); } // 检查当前客户端是否为空，如果为空表示客户端已经被释放 if (server.current_client == NULL) deadclient = 1; /* * 恢复之前的客户端设置。这个恢复是必要的，因为在脚本超时的情况下， * 我们会从 processEventsWhileBlocked 中进入该代码，这会导致设置 server.current_client。 * 如果不恢复，可能会错误地返回 1，表示客户端已经死掉，并停止从客户端缓冲区读取数据。 */ server.current_client = old_client; // performEvictions 可能会刷新从节点的输出缓冲区，这可能导致 // 从节点（可能是当前活动的客户端）被释放。 return deadclient ? C_ERR : C_OK; } 返回写入的resp给client：initServer -&gt; aeSetBeforeSleepProc -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads -&gt; sendReplyToClient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* 将数据写入客户端的输出缓冲区。如果客户端在调用后仍然有效，返回 C_OK， * 如果因错误而被释放，返回 C_ERR。如果设置了 handler_installed，则会尝试清除写事件。 * * 该函数由线程调用，但总是将 handler_installed 设置为 0。因此，当 handler_installed 设置为 0 时， * 该函数必须是线程安全的。*/ int writeToClient(client *c, int handler_installed) { /* 更新服务器的总写入次数 */ atomicIncr(server.stat_total_writes_processed, 1); ssize_t nwritten = 0, totwritten = 0; /* 循环写入客户端的待处理回复 */ while(clientHasPendingReplies(c)) { int ret = _writeToClient(c, &amp;nwritten); if (ret == C_ERR) break; totwritten += nwritten; /* 注意：我们避免一次写入超过 NET_MAX_WRITES_PER_EVENT 字节。 * 在单线程服务器中，即使来自超高速链接的大请求总是能接受数据， * 也应该服务其他客户端（在实际场景中可以考虑 &#39;KEYS *&#39; 命令通过回环接口）。 * * 然而，如果超出了最大内存限制，我们会忽略此限制，尽可能地发送数据。 * * 此外，如果客户端是从节点或监视器，我们会尽可能多地发送数据， * 否则，在高速流量下，复制/输出缓冲区可能会无限增长。*/ if (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp; (server.maxmemory == 0 || zmalloc_used_memory() &lt; server.maxmemory) &amp;&amp; !(c-&gt;flags &amp; CLIENT_SLAVE)) break; } /* 更新统计信息，记录已经发送的字节数 */ if (unlikely(clientTypeIsSlave(c))) { atomicIncr(server.stat_net_repl_output_bytes, totwritten); } else { atomicIncr(server.stat_net_output_bytes, totwritten); } /* 检查写入是否成功 */ if (nwritten == -1) { if (connGetState(c-&gt;conn) != CONN_STATE_CONNECTED) { serverLog(LL_VERBOSE, &#34;Error writing to client: %s&#34;, connGetLastError(c-&gt;conn)); freeClientAsync(c); return C_ERR; } } /* 如果有数据写入，更新客户端的最后交互时间 */ if (totwritten &gt; 0) { /* 对于表示主节点的客户端，不计算发送数据作为一次交互， * 因为我们总是发送 REPLCONF ACK 命令，这些命令只占用一些时间来填充套接字输出缓冲区。 * 我们仅依赖接收到的数据或 ping 命令来检测超时。 */ if (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime; } /* 如果客户端没有待处理的回复 */ if (!clientHasPendingReplies(c)) { c-&gt;sentlen = 0; /* 请注意，writeToClient() 是在线程中调用的，但 aeDeleteFileEvent() 不是线程安全的： * 然而，由于 writeToClient() 总是在线程中将 handler_installed 设置为 0， * 所以我们可以放心。*/ if (handler_installed) { serverAssert(io_threads_op == IO_THREADS_OP_IDLE); connSetWriteHandler(c-&gt;conn, NULL); } /* 在发送完整回复后关闭连接。 */ if (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) { freeClientAsync(c); return C_ERR; } } /* 在写入数据后更新客户端的内存使用情况。 * 由于这不是线程安全的，所以我们会有条件地执行此操作。 * 如果是多线程写入，则将在 handleClientsWithPendingWritesUsingThreads() 中处理。*/ if (io_threads_op == IO_THREADS_OP_IDLE) updateClientMemUsageAndBucket(c); return C_OK; } 内核函数分析 doc：https://man7.org/linux/man-pages/man7/epoll.7.html\n">
    <link rel="shortcut icon" href="/favicon.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/zh-cn/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu897059592634026878.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/zh-cn">wenxin-blog</a></h1>
            <h2 class="site-description">There are some programing and life blog by wenxin.</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/wencynyu'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/zh-cn/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/zh-cn/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/zh-cn/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/zh-cn/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="http://localhost:1313/en/" >English</option>
                                
                                    <option value="http://localhost:1313/zh-cn/" selected>中文</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#源码分析">源码分析</a>
      <ol>
        <li><a href="#系统初始化--eventloop事件循环总线构建">系统初始化 &amp; eventloop事件循环总线构建</a></li>
        <li><a href="#多路复用处理方法类似netty中的handler实现">多路复用处理方法（类似netty中的handler实现）</a>
          <ol>
            <li><a href="#processinputbuffer读取client请求信息">processInputBuffer读取client请求信息</a></li>
            <li><a href="#协议解析">协议解析</a></li>
            <li><a href="#processcommand处理命令">processCommand处理命令</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#内核函数分析">内核函数分析</a>
      <ol>
        <li><a href="#epoll_create">epoll_create</a>
          <ol>
            <li><a href="#参数介绍">参数介绍</a></li>
            <li><a href="#返回值">返回值</a></li>
          </ol>
        </li>
        <li><a href="#epoll_ctl">epoll_ctl</a>
          <ol>
            <li><a href="#参数介绍-1">参数介绍</a></li>
            <li><a href="#返回值-1">返回值</a></li>
          </ol>
        </li>
        <li><a href="#epoll_wait">epoll_wait</a>
          <ol>
            <li><a href="#参数介绍-2">参数介绍</a></li>
            <li><a href="#返回值-2">返回值</a></li>
          </ol>
        </li>
        <li><a href="#边缘触发--水平触发">边缘触发 &amp; 水平触发</a>
          <ol>
            <li><a href="#控制">控制</a></li>
          </ol>
        </li>
        <li><a href="#epoll_wait如何实现等待">epoll_wait如何实现等待</a>
          <ol>
            <li><a href="#总结">总结</a></li>
            <li><a href="#一直没有事件发生的例子">一直没有事件发生的例子</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/zh-cn/categories/%E5%90%8E%E7%AB%AF/" >
                后端
            </a>
        
            <a href="/zh-cn/categories/nosql/" >
                NoSql
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD-reids-%E9%80%9A%E4%BF%A1/">高性能 reids-通信</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Nov 20, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 25 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="redis通信">redis通信
</h1><h2 id="源码分析">源码分析
</h2><h3 id="系统初始化--eventloop事件循环总线构建">系统初始化 &amp; eventloop事件循环总线构建
</h3><ol>
<li>从main函数说起（原300+行，精简部分非核心内容后包含注释100+行）
<ul>
<li>网络通信相关主要为：在main函数中启动epoll监听，io多路复用</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">config_from_stdin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 系统基础依赖初始化：
</span></span></span><span class="line"><span class="cl"><span class="cm">    1. 时区设置
</span></span></span><span class="line"><span class="cl"><span class="cm">    2. 内存oom处理方法
</span></span></span><span class="line"><span class="cl"><span class="cm">    3. 随机数/哈希种子生成
</span></span></span><span class="line"><span class="cl"><span class="cm">    4. crc64校验码初始化
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">exec_name</span> <span class="o">=</span> <span class="nf">strrchr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">exec_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">exec_name</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="p">.</span><span class="n">sentinel_mode</span> <span class="o">=</span> <span class="nf">checkForSentinelMode</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">,</span> <span class="n">exec_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">initServerConfig</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ACLInit</span><span class="p">();</span> <span class="cm">/* 初始化 ACL（访问控制列表）系统，网络连接时需要根据ACL控制权限，此时未加载实际配置 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">moduleInitModulesSystem</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">connTypeInitialize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 存储可执行文件路径和启动参数，用于以后重启服务器 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="p">.</span><span class="n">executable</span> <span class="o">=</span> <span class="nf">getAbsolutePath</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="p">.</span><span class="n">exec_argv</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">argc</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="p">.</span><span class="n">exec_argv</span><span class="p">[</span><span class="n">argc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">server</span><span class="p">.</span><span class="n">exec_argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">zstrdup</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 初始化 Sentinel 相关配置（如果是 Sentinel 模式） */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">sentinel_mode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">initSentinelConfig</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">initSentinel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 检查是否需要启动 redis-check-rdb 或 redis-check-aof 模式 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">strstr</span><span class="p">(</span><span class="n">exec_name</span><span class="p">,</span><span class="s">&#34;redis-check-rdb&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">redis_check_rdb_main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">strstr</span><span class="p">(</span><span class="n">exec_name</span><span class="p">,</span><span class="s">&#34;redis-check-aof&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">redis_check_aof_main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 参数解析 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">sds</span> <span class="n">options</span> <span class="o">=</span> <span class="nf">sdsempty</span><span class="p">();</span> <span class="c1">// 使用内部定义的sds字符串结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 解析特殊参数 --version，--help */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;-v&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">            <span class="nf">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;--version&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sds</span> <span class="n">version</span> <span class="o">=</span> <span class="nf">getVersion</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Redis server %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sdsfree</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;--help&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">            <span class="nf">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;-h&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="nf">usage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">sds</span> <span class="o">*</span><span class="n">argv_tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">argc_tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">handled_last_config_arg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 遍历解析参数 */</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 根据参数完成必要文件配置的加载 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">loadServerConfig</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">configfile</span><span class="p">,</span> <span class="n">config_from_stdin</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">sentinel_mode</span><span class="p">)</span> <span class="nf">loadSentinelConfigFromQueue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sdsfree</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">sentinel_mode</span><span class="p">)</span> <span class="nf">sentinelCheckConfigFile</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 核心：启动服务 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">initServer</span><span class="p">();</span> <span class="c1">// 核心中的核心：载入server对象相关的核心组件：signal信号处理器，thread线程管理器，eventloop事件处理总线等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">background</span> <span class="o">||</span> <span class="n">server</span><span class="p">.</span><span class="n">pidfile</span><span class="p">)</span> <span class="nf">createPidFile</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">set_proc_title</span><span class="p">)</span> <span class="nf">redisSetProcTitle</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">redisAsciiArt</span><span class="p">();</span> <span class="c1">// 打印启动redis的ASCII文字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">checkTcpBacklogSettings</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_enabled</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">clusterInit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">sentinel_mode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">moduleInitModulesSystemLast</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">moduleLoadFromQueue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// acl读取实际配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ACLLoadUsersAtStartup</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">initListeners</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_enabled</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">clusterInitLast</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">InitServerLast</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">sentinel_mode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 非sentinel模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_NOTICE</span><span class="p">,</span><span class="s">&#34;Server initialized&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">aofLoadManifestFromDisk</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">loadDataFromDisk</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">aofOpenIfNeededOnServerStart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">aofDelHistoryFiles</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">applyAppendOnlyConfig</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 集群模式校验
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_enabled</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">serverAssert</span><span class="p">(</span><span class="nf">verifyClusterConfigWithData</span><span class="p">()</span> <span class="o">==</span> <span class="n">C_OK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 打印所有监听器的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CONN_TYPE_MAX</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">connListener</span> <span class="o">*</span><span class="n">listener</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">ct</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_NOTICE</span><span class="p">,</span><span class="s">&#34;Ready to accept connections %s&#34;</span><span class="p">,</span> <span class="n">listener</span><span class="o">-&gt;</span><span class="n">ct</span><span class="o">-&gt;</span><span class="nf">get_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">supervised_mode</span> <span class="o">==</span> <span class="n">SUPERVISED_SYSTEMD</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是由 systemd 监督运行的 Redis 实例，通知 systemd Redis 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sentinelIsRunning</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">supervised_mode</span> <span class="o">==</span> <span class="n">SUPERVISED_SYSTEMD</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果是由 systemd 监督运行的 sentinel 实例，通知 systemd sentinel 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 内存分配过小（1MB）警告 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span><span class="s">&#34;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&#34;</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">redisSetCpuAffinity</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">server_cpulist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">setOOMScoreAdj</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// epoll监听，io多路复用，死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">aeMain</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">aeDeleteEventLoop</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>核心中的核心：initServer方法，载入server对象相关的核心组件：signal信号处理器，thread线程管理器，eventloop事件处理总线等。（原200+行，精简部分非核心内容后包含注释60+行）
<ul>
<li>网络通信相关主要为：在初始化函数中创建thread线程管理器，eventloop事件处理总线</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">initServer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 信号处理器，例如ctrl+c发送SIGKILL信号，此时需要关闭服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">setupSignalHandlers</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 线程管理器初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ThreadsManager_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">makeThreadKillable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 在从配置系统设置默认值后进行初始化 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="p">.</span><span class="n">aof_state</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">aof_enabled</span> <span class="o">?</span> <span class="nl">AOF_ON</span> <span class="p">:</span> <span class="n">AOF_OFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="p">.</span><span class="n">fsynced_reploff</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">aof_enabled</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="p">.</span><span class="n">hz</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">config_hz</span><span class="p">;</span> <span class="c1">// 心跳频率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="nf">getpid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建eventloop事件处理总线，基于epoll机制（linux）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">el</span> <span class="o">=</span> <span class="nf">aeCreateEventLoop</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxclients</span><span class="o">+</span><span class="n">CONFIG_FDSET_INCR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;Failed creating the event loop. Error message: &#39;%s&#39;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="cm">/* 创建定时器回调，这是我们处理许多后台操作的方式，
</span></span></span><span class="line"><span class="cl"><span class="cm">       比如客户端超时、未访问的过期键的淘汰等 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">aeCreateTimeEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">serverCron</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverPanic</span><span class="p">(</span><span class="s">&#34;Can&#39;t create event loop timers.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 为用于唤醒事件循环的管道注册一个可读事件，
</span></span></span><span class="line"><span class="cl"><span class="cm">       用于模块线程间的通信 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">module_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AE_READABLE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">modulePipeReadable</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">serverPanic</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;Error registering the readable event for the module pipe.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 注册epoll阻塞前后的回调函数（需在加载持久化之前完成，因为它会被 processEventsWhileBlocked 使用） */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">aeSetBeforeSleepProc</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">beforeSleep</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">aeSetAfterSleepProc</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">afterSleep</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 32位老系统受限于寻址上限32bit，最多访问2^32个字节，也就是4294967296B -&gt; 4GB，redis会默认限制3GB上限 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">arch_bits</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span><span class="s">&#34;Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with &#39;noeviction&#39; policy now.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">=</span> <span class="mi">3072LL</span><span class="o">*</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span> <span class="cm">/* 3 GB */</span>
</span></span><span class="line"><span class="cl">        <span class="n">server</span><span class="p">.</span><span class="n">maxmemory_policy</span> <span class="o">=</span> <span class="n">MAXMEMORY_NO_EVICTION</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 脚本系统初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">luaEnvInit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">scriptingInit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">functionsInit</span><span class="p">()</span> <span class="o">==</span> <span class="n">C_ERR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverPanic</span><span class="p">(</span><span class="s">&#34;Functions initialization failed, check the server logs.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 基本监控初始化：提供慢查询告警/延迟监控等功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">slowlogInit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">latencyMonitorInit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 参照配置初始化密码，一般不启用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ACLUpdateDefaultUserPassword</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">requirepass</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 定时器功能初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">applyWatchdogPeriod</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory_clients</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">initServerClientMemUsageBuckets</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>aeCreateEventLoop方法：创建事件循环总线</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">aeEventLoop</span> <span class="o">*</span><span class="nf">aeCreateEventLoop</span><span class="p">(</span><span class="kt">int</span> <span class="n">setsize</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">monotonicInit</span><span class="p">();</span>    <span class="cm">/* just in case the calling app didn&#39;t initialize */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 分配内存：最大感兴趣的fd为setsize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">eventLoop</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">eventLoop</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aeFileEvent</span><span class="p">)</span><span class="o">*</span><span class="n">setsize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aeFiredEvent</span><span class="p">)</span><span class="o">*</span><span class="n">setsize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">setsize</span> <span class="o">=</span> <span class="n">setsize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventNextId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">aftersleep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">aeApiCreate</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span> <span class="c1">// 核心：调用封装的函数aeApiCreate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/* Events的关注事件默认置为0（不关注任何事件）*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">setsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="n">AE_NONE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">eventLoop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">err</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 失败则释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*  ae_epoll.c，仅在上面代码中调用，创建事件总线	
</span></span></span><span class="line"><span class="cl"><span class="cm">	这里依赖系统内置库函数：epoll_create，其中size参数仅为参考值，对较新的linux版本来说无实际作用
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiCreate</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aeApiState</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)</span><span class="o">*</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">setsize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span> <span class="o">=</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="cm">/* 1024 is just a hint for the kernel */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">anetCloexec</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>ae_epoll.c封装系统库函数（无精简）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeApiState</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">epfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">aeApiState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 仅在aeCreateEventLoop代码中调用，创建事件总线	
</span></span></span><span class="line"><span class="cl"><span class="cm">   依赖系统内置库函数：epoll_create，其中：
</span></span></span><span class="line"><span class="cl"><span class="cm">   size参数仅为参考值，对较新的linux版本来说无实际作用
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiCreate</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aeApiState</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)</span><span class="o">*</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">setsize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span> <span class="o">=</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="cm">/* 1024 is just a hint for the kernel */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">anetCloexec</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// resize event数组，类似vector(c)/list(java)/slice(golang/python)动态扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiResize</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">setsize</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">=</span> <span class="nf">zrealloc</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)</span><span class="o">*</span><span class="n">setsize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 释放资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">aeApiFree</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">zfree</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 在eventloop中注册新的fd，mask为感兴趣的事件
</span></span></span><span class="line"><span class="cl"><span class="cm">   依赖系统内置库函数epoll_ctl，其中：
</span></span></span><span class="line"><span class="cl"><span class="cm">   epfd为事件总线fd，
</span></span></span><span class="line"><span class="cl"><span class="cm">   op为注册操作，枚举EPOLL_CTL_ADD, EPOLL_CTL_ADD, EPOLL_CTL_DEL，
</span></span></span><span class="line"><span class="cl"><span class="cm">   fd为注册的新fd，
</span></span></span><span class="line"><span class="cl"><span class="cm">   ee为新建的epoll_event结构体实例
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiAddEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ee</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* avoid valgrind warning */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* If the fd was already monitored for some event, we need a MOD
</span></span></span><span class="line"><span class="cl"><span class="cm">     * operation. Otherwise we need an ADD operation. */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">op</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span> <span class="o">==</span> <span class="n">AE_NONE</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">            <span class="nl">EPOLL_CTL_ADD</span> <span class="p">:</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mask</span> <span class="o">|=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="cm">/* Merge old events */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ee</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">op</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ee</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 在eventloop中注册新的fd，mask为感兴趣的事件
</span></span></span><span class="line"><span class="cl"><span class="cm">   依赖系统内置库函数epoll_ctl，其中：
</span></span></span><span class="line"><span class="cl"><span class="cm">   epfd为事件总线fd，
</span></span></span><span class="line"><span class="cl"><span class="cm">   op为注册操作，枚举EPOLL_CTL_ADD, EPOLL_CTL_ADD, EPOLL_CTL_DEL，
</span></span></span><span class="line"><span class="cl"><span class="cm">   fd为注册的新fd，
</span></span></span><span class="line"><span class="cl"><span class="cm">   ee为新建的epoll_event结构体实例，关注的mask写在这个结构体中
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">aeApiDelEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delmask</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ee</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* avoid valgrind warning */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">delmask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ee</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="n">AE_NONE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ee</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for
</span></span></span><span class="line"><span class="cl"><span class="cm">         * EPOLL_CTL_DEL. */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ee</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 在eventloop中注册新的fd，mask为感兴趣的事件
</span></span></span><span class="line"><span class="cl"><span class="cm">   依赖系统内置库函数epoll_wait，其中：
</span></span></span><span class="line"><span class="cl"><span class="cm">   epfd为事件总线fd，
</span></span></span><span class="line"><span class="cl"><span class="cm">   events为已注册的全部感兴趣事件，
</span></span></span><span class="line"><span class="cl"><span class="cm">   tvp相关为等待时间，-1为一直阻塞，直到有注册的感兴趣事件发生
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiPoll</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">numevents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">retval</span> <span class="o">=</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">setsize</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">tvp</span> <span class="o">?</span> <span class="p">(</span><span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="o">*</span><span class="mi">1000</span> <span class="o">+</span> <span class="p">(</span><span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">+</span> <span class="mi">999</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">numevents</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_READABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLERR</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="o">|</span><span class="n">AE_READABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLHUP</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="o">|</span><span class="n">AE_READABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;aeApiPoll: epoll_wait, %s&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">numevents</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">aeApiName</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s">&#34;epoll&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>哪些地方调用了注册事件
<ul>
<li><strong>server启动过程中：initListeners -&gt; createSocketAcceptHandler （accept）</strong>
<ul>
<li>connSocketAcceptHandler</li>
</ul>
</li>
<li><strong>创建客户端连接时：ConnectionType -&gt; connSocketConnect（connect）</strong>
<ul>
<li>ae_handler -&gt; connSocketSetReadHandler
<ul>
<li>建立client通信时：createClient -&gt; readQueryFromClient</li>
</ul>
</li>
<li>ae_handler -&gt; connSocketSetWriteHandler
<ul>
<li>初始化服务端时：initServer -&gt; aeSetBeforeSleepProc -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads -&gt; sendReplyToClient</li>
</ul>
</li>
</ul>
</li>
<li>同步rdb数据：initServer -&gt; aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) -&gt; serverCron -&gt; checkChildrenDone -&gt; replicationStartPendingFork -&gt; rdbSaveToSlavesSockets
<ul>
<li>rdbPipeReadHandler</li>
</ul>
</li>
<li>sentinel通信：initServer -&gt; aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) -&gt; serverCron -&gt; sentinelTimer -&gt; sentinelHandleDictOfRedisInstances -&gt; sentinelHandleRedisInstance -&gt; sentinelReconnectInstance -&gt; redisAeAttach -&gt; redisAeAddWrite</li>
<li>pipeline管道的bio通信：initServer -&gt; InitServerLast -&gt; bioInit</li>
</ul>
</li>
<li>注册事件处理：main -&gt; aeMain -&gt; aeApiPoll -&gt; epoll_wait</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 死循环处理事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">aeMain</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">aeProcessEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">AE_ALL_EVENTS</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">AE_CALL_BEFORE_SLEEP</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">AE_CALL_AFTER_SLEEP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxfd</span><span class="p">;</span>   <span class="cm">/* highest file descriptor currently registered */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">setsize</span><span class="p">;</span> <span class="cm">/* max number of file descriptors tracked */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">timeEventNextId</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span> <span class="cm">/* Registered events */</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeFiredEvent</span> <span class="o">*</span><span class="n">fired</span><span class="p">;</span> <span class="cm">/* Fired events */</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">timeEventHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">stop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">apidata</span><span class="p">;</span> <span class="cm">/* This is used for polling API specific data */</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeBeforeSleepProc</span> <span class="o">*</span><span class="n">beforesleep</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeBeforeSleepProc</span> <span class="o">*</span><span class="n">aftersleep</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">aeEventLoop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeFileEvent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span> <span class="cm">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">rfileProc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">wfileProc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">aeFileEvent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">aeProcessEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numevents</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果没有文件事件和时间事件需要处理，直接返回 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_FILE_EVENTS</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 即使没有文件事件，如果有时间事件，也需要调用 aeApiPoll 来等待下一次时间事件的触发 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">,</span> <span class="o">*</span><span class="n">tvp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* NULL means infinite wait. */</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int64_t</span> <span class="n">usUntilTimer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_CALL_BEFORE_SLEEP</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* Before sleep callback. */</span>
</span></span><span class="line"><span class="cl">            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="nf">beforesleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* eventLoop-&gt;flags 可能会在 beforeSleep 中发生改变，所以需要在调用 beforeSleep 后重新检查
</span></span></span><span class="line"><span class="cl"><span class="cm">		   同时，flags 参数优先级更高，特别是 AE_DONT_WAIT 设置时，应忽略 eventLoop-&gt;flags 中的值 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">tvp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">usUntilTimer</span> <span class="o">=</span> <span class="nf">usUntilEarliestTimer</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">usUntilTimer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">usUntilTimer</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">usUntilTimer</span> <span class="o">%</span> <span class="mi">1000000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">tvp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 调用aeApiPoll多路复用方法，Call the multiplexing API, will return only on timeout or when some event fires. */</span>
</span></span><span class="line"><span class="cl">        <span class="n">numevents</span> <span class="o">=</span> <span class="nf">aeApiPoll</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">tvp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果没有请求处理文件事件，就跳过文件事件的处理 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_FILE_EVENTS</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">numevents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* After sleep callback. */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">aftersleep</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_CALL_AFTER_SLEEP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="nf">aftersleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">fired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Number of events fired for current fd. */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* 默认情况下，先执行可读事件，再执行可写事件。这个顺序可以确保有可读数据时，优先处理读取请求。
</span></span></span><span class="line"><span class="cl"><span class="cm">             * 如果设置了 AE_BARRIER 标志，则表示我们希望反转执行顺序，先执行可写事件。 */</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">invert</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_BARRIER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* 检查事件是否仍然有效：可能已经处理过的事件在当前回合中已经被移除 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">invert</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">fe</span><span class="o">-&gt;</span><span class="nf">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">fired</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span> <span class="cm">/* Refresh in case of resize. */</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* 执行可写事件 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fired</span> <span class="o">||</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">!=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">fe</span><span class="o">-&gt;</span><span class="nf">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">fired</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">             <span class="cm">/* 如果需要反转执行顺序，在可写事件后执行可读事件 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">invert</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span> <span class="cm">/* Refresh in case of resize. */</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">((</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">(</span><span class="o">!</span><span class="n">fired</span> <span class="o">||</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">!=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">fe</span><span class="o">-&gt;</span><span class="nf">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">fired</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果需要处理时间事件，则继续处理时间事件 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">processed</span> <span class="o">+=</span> <span class="nf">processTimeEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="多路复用处理方法类似netty中的handler实现">多路复用处理方法（类似netty中的handler实现）
</h3><ol start="7">
<li>协议解析：createClient -&gt; readQueryFromClient -&gt; processInputBuffer -&gt; processXXXBuffer -&gt; processCommandAndResetClient
<ul>
<li>inline：processInlineBuffer</li>
<li>multi：processMultibulkBuffer</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">readQueryFromClient</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">client</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="nf">connGetPrivateData</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">nread</span><span class="p">,</span> <span class="n">big_arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">qblen</span><span class="p">,</span> <span class="n">readlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果启用了线程化 I/O，并且需要在退出事件循环时稍后读取客户端数据 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">postponeClientRead</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更新服务器的总读取次数 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">atomicIncr</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">stat_total_reads_processed</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">readlen</span> <span class="o">=</span> <span class="n">PROTO_IOBUF_LEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果这是一个多批量请求，并且正在处理一个较大的批量回复，尽量确保查询缓冲区
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 精确包含表示对象的 SDS 字符串，即使这可能会导致更多的 read(2) 调用。 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 这样，函数 processMultiBulkBuffer() 可以避免复制缓冲区来创建 Redis 对象。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">==</span> <span class="n">PROTO_REQ_MULTIBULK</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">&gt;=</span> <span class="n">PROTO_MBULK_BIG_ARG</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 对于大的参数，客户端总是使用其私有的查询缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 使用可重用的查询缓冲区可能会导致其超出 32k，最终让客户端接管这个缓冲区。 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="nf">sdsempty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">ssize_t</span> <span class="n">remaining</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span><span class="o">-</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">big_arg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 注意：&#39;remaining&#39; 变量在某些边缘情况下可能为零，例如当在 CLIENT PAUSE 后恢复被阻塞的客户端时 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">readlen</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果是主客户端，在遇到大参数时需要扩大读取长度，但不需要对齐到下一个参数，可以读取更多数据 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span> <span class="o">&amp;&amp;</span> <span class="n">readlen</span> <span class="o">&lt;</span> <span class="n">PROTO_IOBUF_LEN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">readlen</span> <span class="o">=</span> <span class="n">PROTO_IOBUF_LEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">thread_reusable_qb_used</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 如果可重用的查询缓冲区已被其他客户端使用，切换到使用客户端的私有查询缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="cm">             * 这种情况仅在通过 processEventsWhileBlocked() 执行嵌套命令时发生。 */</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="nf">sdsnewlen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">PROTO_IOBUF_LEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sdsclear</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 如果查询缓冲区不存在，则创建可重用的查询缓冲区 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thread_reusable_qb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">thread_reusable_qb</span> <span class="o">=</span> <span class="nf">sdsnewlen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">PROTO_IOBUF_LEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">sdsclear</span><span class="p">(</span><span class="n">thread_reusable_qb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* 将可重用的查询缓冲区分配给客户端，并标记为正在使用 */</span>
</span></span><span class="line"><span class="cl">            <span class="nf">serverAssert</span><span class="p">(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">thread_reusable_qb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="n">thread_reusable_qb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLIENT_REUSABLE_QUERYBUFFER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">thread_reusable_qb_used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">qblen</span> <span class="o">=</span> <span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// 主客户端的查询缓冲区可以贪婪扩展
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">(</span><span class="n">big_arg</span> <span class="o">||</span> <span class="nf">sdsalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PROTO_IOBUF_LEN</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 在读取大参数时，我们不会读取超过一个参数的内容到查询缓冲区，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 所以不需要预分配多于所需的空间，因此使用非贪婪扩展。 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="nf">sdsMakeRoomForNonGreedy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="n">readlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 稍后将峰值设置为已使用的部分，但这里我们过度分配，因为我们知道需要的空间，确保在使用前不会被缩小。 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf_peak</span> <span class="o">&lt;</span> <span class="n">qblen</span> <span class="o">+</span> <span class="n">readlen</span><span class="p">)</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf_peak</span> <span class="o">=</span> <span class="n">qblen</span> <span class="o">+</span> <span class="n">readlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="nf">sdsMakeRoomFor</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="n">readlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 从套接字中尽可能多地读取数据，以节省 read(2) 系统调用次数。 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">readlen</span> <span class="o">=</span> <span class="nf">sdsavail</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">nread</span> <span class="o">=</span> <span class="nf">connRead</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="o">+</span><span class="n">qblen</span><span class="p">,</span> <span class="n">readlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">connGetState</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="o">==</span> <span class="n">CONN_STATE_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_VERBOSE</span><span class="p">,</span> <span class="s">&#34;从客户端读取数据时出错: %s&#34;</span><span class="p">,</span> <span class="nf">connGetLastError</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="nf">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">verbosity</span> <span class="o">&lt;=</span> <span class="n">LL_VERBOSE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sds</span> <span class="n">info</span> <span class="o">=</span> <span class="nf">catClientInfoString</span><span class="p">(</span><span class="nf">sdsempty</span><span class="p">(),</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_VERBOSE</span><span class="p">,</span> <span class="s">&#34;客户端关闭了连接 %s&#34;</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sdsfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更新查询缓冲区的长度 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sdsIncrLen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="n">nread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">qblen</span> <span class="o">=</span> <span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf_peak</span> <span class="o">&lt;</span> <span class="n">qblen</span><span class="p">)</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf_peak</span> <span class="o">=</span> <span class="n">qblen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更新最后交互时间 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">lastinteraction</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">read_reploff</span> <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">atomicIncr</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">stat_net_repl_input_bytes</span><span class="p">,</span> <span class="n">nread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">atomicIncr</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">stat_net_input_bytes</span><span class="p">,</span> <span class="n">nread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 对于普通客户端，如果查询缓冲区的大小超过限制或需要身份验证，则关闭客户端连接 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* MULTI/EXEC 队列中的命令尚未执行，因此它们也算作查询缓冲区的一部分 */</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mstate</span><span class="p">.</span><span class="n">argv_len_sums</span> <span class="o">+</span> <span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">client_max_querybuf_len</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mstate</span><span class="p">.</span><span class="n">argv_len_sums</span> <span class="o">+</span> <span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="nf">authRequired</span><span class="p">(</span><span class="n">c</span><span class="p">))))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sds</span> <span class="n">ci</span> <span class="o">=</span> <span class="nf">catClientInfoString</span><span class="p">(</span><span class="nf">sdsempty</span><span class="p">(),</span><span class="n">c</span><span class="p">),</span> <span class="n">bytes</span> <span class="o">=</span> <span class="nf">sdsempty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">bytes</span> <span class="o">=</span> <span class="nf">sdscatrepr</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span><span class="mi">64</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span><span class="s">&#34;关闭客户端，查询缓冲区超过最大限制: %s (查询缓冲区初始字节: %s)&#34;</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sdsfree</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sdsfree</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">atomicIncr</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">stat_client_qbuf_limit_disconnections</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果客户端输入缓冲区还有数据，继续解析并检查是否有完整的命令需要执行 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">processInputBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">C_ERR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="n">c</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_REUSABLE_QUERYBUFFER</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverAssert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* 确保客户端的查询缓冲区在 processInputBuffer 中被修剪 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">resetReusableQueryBuf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">beforeNextClient</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="processinputbuffer读取client请求信息">processInputBuffer读取client请求信息
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* 该函数在每次客户端结构体 &#39;c&#39; 中有更多查询缓冲区需要处理时被调用，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 可能是因为我们从套接字读取了更多的数据，或者客户端被阻塞并在之后重新激活，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 所以可能存在待处理的查询缓冲区，这些缓冲区可能已经代表一个完整的命令需要处理。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果在处理过程中客户端已经被释放，则返回 C_ERR */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">processInputBuffer</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 当输入缓冲区有内容时，继续处理 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">&lt;</span> <span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果客户端当前被阻塞，立即中止 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_BLOCKED</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果客户端有待处理的命令，不要继续处理更多的缓冲区 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_PENDING_COMMAND</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果客户端是主客户端，并且当前有忙碌脚本，暂停处理输入 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">isInsideYieldingLongCommand</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果设置了 CLIENT_CLOSE_AFTER_REPLY 标志，处理完回复后就关闭连接，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 不允许继续处理更多的命令 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CLIENT_CLOSE_AFTER_REPLY</span><span class="o">|</span><span class="n">CLIENT_CLOSE_ASAP</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果请求类型未知，判断请求类型 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">=</span> <span class="n">PROTO_REQ_MULTIBULK</span><span class="p">;</span>  <span class="c1">// 多批量请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">=</span> <span class="n">PROTO_REQ_INLINE</span><span class="p">;</span>  <span class="c1">// 单行命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 根据请求类型处理缓冲区 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">==</span> <span class="n">PROTO_REQ_INLINE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">processInlineBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">C_OK</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// 处理单行命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reqtype</span> <span class="o">==</span> <span class="n">PROTO_REQ_MULTIBULK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">processMultibulkBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">C_OK</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// 处理多批量命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">serverPanic</span><span class="p">(</span><span class="s">&#34;Unknown request type&#34;</span><span class="p">);</span>  <span class="c1">// 未知的请求类型，程序崩溃
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 多批量请求处理可能导致 argc &lt;= 0 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">resetClientInternal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 如果没有有效的参数，重置客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 如果是 I/O 线程上下文，不能在此执行命令，只能标记客户端需要处理命令 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_op</span> <span class="o">!=</span> <span class="n">IO_THREADS_OP_IDLE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">serverAssert</span><span class="p">(</span><span class="n">io_threads_op</span> <span class="o">==</span> <span class="n">IO_THREADS_OP_READ</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLIENT_PENDING_COMMAND</span><span class="p">;</span>  <span class="c1">// 设置为待处理命令状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* 准备好执行命令了 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">processCommandAndResetClient</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">C_ERR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* 如果客户端已经不再有效，避免继续执行，直接返回 */</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果客户端是主客户端，需要裁剪查询缓冲区 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果客户端是主客户端，裁剪查询缓冲区到 repl_applied 指定的位置，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 因为主客户端的查询缓冲区不仅用于解析命令，还用于代理给子复制实例。
</span></span></span><span class="line"><span class="cl"><span class="cm">         *
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 需要裁剪查询缓冲区的场景：
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 1. 没有接收到完整的命令
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 2. 主客户端因为客户端暂停而被阻塞
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 3. I/O 线程操作读取，主客户端被标记为 CLIENT_PENDING_COMMAND
</span></span></span><span class="line"><span class="cl"><span class="cm">         *
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 在这些场景下，qb_pos 指向当前命令的一部分或下一个命令的开始位置，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 当前命令尚未应用，因此 repl_applied 不等于 qb_pos。*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_applied</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sdsrange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_applied</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 剩余的命令数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">-=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_applied</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_applied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果客户端不是主客户端，裁剪查询缓冲区 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sdsrange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 将查询缓冲区裁剪到当前位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 重置查询缓冲区位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 在处理查询缓冲区后更新客户端的内存使用情况，
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 这对查询缓冲区比较大且没有在上述循环中被完全处理的客户端很重要（
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 例如部分发送的大命令）。*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_op</span> <span class="o">==</span> <span class="n">IO_THREADS_OP_IDLE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">updateClientMemUsageAndBucket</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>  <span class="c1">// 返回处理成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="协议解析">协议解析
</h4><ul>
<li>processInlineBuffer：set a b这样的简单命令</li>
<li>processMultibulkBuffer：mset a b c d这样的复合命令</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* 类似于 processMultibulkBuffer()，但是用于处理 inline 协议，而不是 RESP 协议。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数消耗客户端的查询缓冲区，并在客户端结构体中创建一个准备执行的命令。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果命令已经准备好执行，则返回 C_OK；如果仍然需要读取更多协议数据才能形成一个有效的命令，则返回 C_ERR。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 当出现协议错误时，返回 C_ERR；在这种情况下，客户端结构体会被设置为回复错误并关闭连接。 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">processInlineBuffer</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">newline</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">linefeed_chars</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sds</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span> <span class="n">aux</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">querylen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 查找换行符的位置 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">newline</span> <span class="o">=</span> <span class="nf">strchr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果没有找到 \r\n 则返回，不做处理 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">newline</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">&gt;</span> <span class="n">PROTO_INLINE_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: too big inline request&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;too big inline request&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 处理 \r\n 的情况 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">newline</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">newline</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">newline</span><span class="o">--</span><span class="p">;</span>  <span class="c1">// 将 newline 指向 \r 的前一个字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">linefeed_chars</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 计算换行符的字符数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 截取从当前指针到 \r\n 之间的内容 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">querylen</span> <span class="o">=</span> <span class="n">newline</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="o">=</span> <span class="nf">sdsnewlen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">,</span> <span class="n">querylen</span><span class="p">);</span>  <span class="c1">// 创建一个新的 sds 字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">argv</span> <span class="o">=</span> <span class="nf">sdssplitargs</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argc</span><span class="p">);</span>  <span class="c1">// 分割命令行参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sdsfree</span><span class="p">(</span><span class="n">aux</span><span class="p">);</span>  <span class="c1">// 释放临时变量 aux
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">argv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: unbalanced quotes in request&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;unbalanced quotes in inline request&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果查询长度为 0 且客户端是从属节点，
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 则表示通过换行符刷新最后的 ACK 时间。
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 这是为了让从属节点在加载大型 RDB 文件时能够持续保持连接 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">querylen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">clientTypeIsSlave</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_ack_time</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 主节点不应该发送 inline 协议来执行实际的命令。
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果发生这种情况，可能是 Redis 协议出现了同步问题，
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 比如由于 PSYNC 出错导致的协议不一致。
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 但是有一个例外：主节点可能只会发送一个换行符来保持连接活动。 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">querylen</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sdsfreesplitres</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>  <span class="c1">// 释放参数数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span> <span class="s">&#34;WARNING: Receiving inline protocol from master, master stream corruption? Closing the master connection and discarding the cached master.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;Master using the inline protocol. Desync?&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 移动查询缓冲区位置，指向下一个查询命令 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">+=</span> <span class="n">querylen</span> <span class="o">+</span> <span class="n">linefeed_chars</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 在客户端结构体中设置 argv 数组 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果参数数量超过当前分配的空间，重新分配内存 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">zfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">);</span>  <span class="c1">// 释放旧的 argv
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">robj</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">argc</span><span class="p">);</span>  <span class="c1">// 分配新的 argv 数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 重置参数长度总和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 为所有的参数创建 Redis 对象 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">]</span> <span class="o">=</span> <span class="nf">createObject</span><span class="p">(</span><span class="n">OBJ_STRING</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>  <span class="c1">// 创建字符串类型的 Redis 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 增加参数计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len_sum</span> <span class="o">+=</span> <span class="nf">sdslen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>  <span class="c1">// 更新参数总长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">zfree</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span>  <span class="c1">// 释放临时分割后的参数数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>  <span class="c1">// 返回命令已准备好执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 处理客户端 &#39;c&#39; 的查询缓冲区，并为命令执行设置客户端的参数向量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果客户端有一个格式正确、准备执行的命令，返回 C_OK，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 否则，如果还需要更多的数据才能获得完整的命令，返回 C_ERR。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果出现协议错误，返回 C_ERR；在这种情况下，客户端结构会被设置为回复错误并关闭连接。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 当 processInputBuffer() 检测到下一个命令是 RESP 格式时会调用此函数，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 因为命令的第一个字节是 &#39;*&#39;。否则，对于 inline 命令会调用 processInlineBuffer()。*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">processMultibulkBuffer</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">newline</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ok</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 客户端应该已经被重置 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 多重批量长度不能在没有 \r\n 的情况下读取 */</span>
</span></span><span class="line"><span class="cl">        <span class="n">newline</span> <span class="o">=</span> <span class="nf">strchr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">,</span> <span class="sc">&#39;\r&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">newline</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">&gt;</span> <span class="n">PROTO_INLINE_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: too big mbulk count string&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;too big mbulk count string&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 缓冲区中应也包含 \n */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">newline</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 确定这是一整行，因为 newline != NULL，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 所以可以继续解析多重批量长度 */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">serverAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ok</span> <span class="o">=</span> <span class="nf">string2ll</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">,</span> <span class="n">newline</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ll</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span> <span class="o">||</span> <span class="n">ll</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: invalid multibulk length&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;invalid mbulk count&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="nf">authRequired</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: unauthenticated multibulk length&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;unauth mbulk count&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">newline</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 在客户端结构体中设置 argv 数组。
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 如果空间不足或者需要逐步分配空间，创建新的 argv */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">zfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span> <span class="o">=</span> <span class="nf">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">robj</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">serverAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 如果未知，读取批量长度 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">newline</span> <span class="o">=</span> <span class="nf">strchr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">,</span> <span class="sc">&#39;\r&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">newline</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">&gt;</span> <span class="n">PROTO_INLINE_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: too big bulk count string&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;too big bulk count string&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* 缓冲区中也应该包含 \n */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">newline</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: expected &#39;$&#39;, got &#39;%c&#39;&#34;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;expected $ but got something else&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">ok</span> <span class="o">=</span> <span class="nf">string2ll</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">newline</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ll</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span> <span class="o">||</span> <span class="n">ll</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ll</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">proto_max_bulk_len</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: invalid bulk length&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;invalid bulk length&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;</span> <span class="mi">16384</span> <span class="o">&amp;&amp;</span> <span class="nf">authRequired</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#34;Protocol error: unauthenticated bulk length&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">setProtocolError</span><span class="p">(</span><span class="s">&#34;unauth bulk length&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">=</span> <span class="n">newline</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ll</span> <span class="o">&gt;=</span> <span class="n">PROTO_MBULK_BIG_ARG</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* 如果客户端不是主节点（因为主节点的查询缓冲区只能在数据应用并发送给从节点后修剪）。
</span></span></span><span class="line"><span class="cl"><span class="cm">                 *
</span></span></span><span class="line"><span class="cl"><span class="cm">                 * 如果我们将从网络读取一个较大的对象，尝试使其从 c-&gt;querybuf 边界开始，这样可以优化对象创建，
</span></span></span><span class="line"><span class="cl"><span class="cm">                 * 避免对数据进行大量复制。
</span></span></span><span class="line"><span class="cl"><span class="cm">                 *
</span></span></span><span class="line"><span class="cl"><span class="cm">                 * 但是只有当未解析的数据长度小于或等于 ll+2 时才这样做。否则，修剪查询缓冲区就是浪费时间，
</span></span></span><span class="line"><span class="cl"><span class="cm">                 * 因为此时查询缓冲区不仅仅包含我们的大批量数据。 */</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">ll</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">sdsrange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* 提示 sds 库有关字符串长度的预期 */</span>
</span></span><span class="line"><span class="cl">                    <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="nf">sdsMakeRoomForNonGreedy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="n">ll</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                    <span class="cm">/* 我们后续会设置峰值为使用的部分，但此时超额分配是为了确保不会在使用前被缩小 */</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf_peak</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">ll</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf_peak</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 读取批量参数 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 数据不足（+2 是指尾部的 \r\n） */</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* 检查是否有足够的空间存储参数，如果没有则进行扩展 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span> <span class="o">=</span> <span class="nf">zrealloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">robj</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* 优化：如果非主节点客户端的缓冲区仅包含我们的批量元素，
</span></span></span><span class="line"><span class="cl"><span class="cm">             * 那么直接使用当前的 sds 字符串而不是通过复制创建一个新的对象 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">&gt;=</span> <span class="n">PROTO_MBULK_BIG_ARG</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="nf">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nf">createObject</span><span class="p">(</span><span class="n">OBJ_STRING</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len_sum</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nf">sdsIncrLen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="cm">/* 去除 CRLF */</span>
</span></span><span class="line"><span class="cl">                <span class="cm">/* 假设如果我们看到一个大的参数，接下来可能会看到另一个类似的 */</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">=</span> <span class="nf">sdsnewlen</span><span class="p">(</span><span class="n">SDS_NOINIT</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">sdsclear</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">createStringObject</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">querybuf</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv_len_sum</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="o">-&gt;</span><span class="n">qb_pos</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">bulklen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 当 c-&gt;multibulklen 为 0 时，表示命令处理完成 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">multibulklen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 仍然没有准备好处理命令 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="processcommand处理命令">processCommand处理命令
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* 这个函数调用 processCommand()，同时执行一些对于客户端来说有用的额外任务：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 将当前客户端设置为 &#39;c&#39;。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 如果命令已处理，则调用 commandProcessed()。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果处理命令过程中客户端被释放，则返回 C_ERR，否则返回 C_OK。 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">processCommandAndResetClient</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">deadclient</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">client</span> <span class="o">*</span><span class="n">old_client</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">current_client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置当前处理的客户端为 &#39;c&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">processCommand</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">C_OK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果命令成功处理，调用 commandProcessed()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">commandProcessed</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 更新客户端的内存使用情况，考虑到命令执行后可能导致输出缓冲区的增长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">)</span> <span class="nf">updateClientMemUsageAndBucket</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查当前客户端是否为空，如果为空表示客户端已经被释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">deadclient</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 恢复之前的客户端设置。这个恢复是必要的，因为在脚本超时的情况下，
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 我们会从 processEventsWhileBlocked 中进入该代码，这会导致设置 server.current_client。
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果不恢复，可能会错误地返回 1，表示客户端已经死掉，并停止从客户端缓冲区读取数据。
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">server</span><span class="p">.</span><span class="n">current_client</span> <span class="o">=</span> <span class="n">old_client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// performEvictions 可能会刷新从节点的输出缓冲区，这可能导致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从节点（可能是当前活动的客户端）被释放。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">deadclient</span> <span class="o">?</span> <span class="nl">C_ERR</span> <span class="p">:</span> <span class="n">C_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>返回写入的resp给client：initServer -&gt; aeSetBeforeSleepProc -&gt; beforeSleep -&gt; handleClientsWithPendingWritesUsingThreads -&gt; sendReplyToClient</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* 将数据写入客户端的输出缓冲区。如果客户端在调用后仍然有效，返回 C_OK，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果因错误而被释放，返回 C_ERR。如果设置了 handler_installed，则会尝试清除写事件。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数由线程调用，但总是将 handler_installed 设置为 0。因此，当 handler_installed 设置为 0 时，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数必须是线程安全的。*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">writeToClient</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">handler_installed</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更新服务器的总写入次数 */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">atomicIncr</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">stat_total_writes_processed</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">ssize_t</span> <span class="n">nwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">totwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 循环写入客户端的待处理回复 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="nf">clientHasPendingReplies</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">_writeToClient</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nwritten</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">C_ERR</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">totwritten</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 注意：我们避免一次写入超过 NET_MAX_WRITES_PER_EVENT 字节。
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 在单线程服务器中，即使来自超高速链接的大请求总是能接受数据，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 也应该服务其他客户端（在实际场景中可以考虑 &#39;KEYS *&#39; 命令通过回环接口）。
</span></span></span><span class="line"><span class="cl"><span class="cm">         *
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 然而，如果超出了最大内存限制，我们会忽略此限制，尽可能地发送数据。
</span></span></span><span class="line"><span class="cl"><span class="cm">         *
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 此外，如果客户端是从节点或监视器，我们会尽可能多地发送数据，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 否则，在高速流量下，复制/输出缓冲区可能会无限增长。*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">totwritten</span> <span class="o">&gt;</span> <span class="n">NET_MAX_WRITES_PER_EVENT</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">             <span class="nf">zmalloc_used_memory</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">maxmemory</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_SLAVE</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更新统计信息，记录已经发送的字节数 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">clientTypeIsSlave</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">atomicIncr</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">stat_net_repl_output_bytes</span><span class="p">,</span> <span class="n">totwritten</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">atomicIncr</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">stat_net_output_bytes</span><span class="p">,</span> <span class="n">totwritten</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 检查写入是否成功 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">connGetState</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CONN_STATE_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">serverLog</span><span class="p">(</span><span class="n">LL_VERBOSE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;Error writing to client: %s&#34;</span><span class="p">,</span> <span class="nf">connGetLastError</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="nf">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果有数据写入，更新客户端的最后交互时间 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">totwritten</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 对于表示主节点的客户端，不计算发送数据作为一次交互，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 因为我们总是发送 REPLCONF ACK 命令，这些命令只占用一些时间来填充套接字输出缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 我们仅依赖接收到的数据或 ping 命令来检测超时。 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_MASTER</span><span class="p">))</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lastinteraction</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 如果客户端没有待处理的回复 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">clientHasPendingReplies</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">sentlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* 请注意，writeToClient() 是在线程中调用的，但 aeDeleteFileEvent() 不是线程安全的：
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 然而，由于 writeToClient() 总是在线程中将 handler_installed 设置为 0，
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 所以我们可以放心。*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">handler_installed</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">serverAssert</span><span class="p">(</span><span class="n">io_threads_op</span> <span class="o">==</span> <span class="n">IO_THREADS_OP_IDLE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">connSetWriteHandler</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">conn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* 在发送完整回复后关闭连接。 */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLIENT_CLOSE_AFTER_REPLY</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 在写入数据后更新客户端的内存使用情况。
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 由于这不是线程安全的，所以我们会有条件地执行此操作。
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果是多线程写入，则将在 handleClientsWithPendingWritesUsingThreads() 中处理。*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">io_threads_op</span> <span class="o">==</span> <span class="n">IO_THREADS_OP_IDLE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">updateClientMemUsageAndBucket</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">C_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="内核函数分析">内核函数分析
</h2><p>doc：https://man7.org/linux/man-pages/man7/epoll.7.html</p>
<h3 id="epoll_create">epoll_create
</h3><p>int epoll_create(int size);</p>
<h4 id="参数介绍">参数介绍
</h4><p><strong>size</strong>：这个参数是建议值，用于指定内部事件数组的大小。实际应用中，这个值一般可以传入一个合适的值，<code>epoll</code> 内部会根据操作系统的能力来分配内存。此参数已经在 Linux 2.6.8 中被废弃，并且没有实际意义，但为了兼容，依然存在。</p>
<h4 id="返回值">返回值
</h4><p>fd文件描述符id。</p>
<h3 id="epoll_ctl">epoll_ctl
</h3><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<h4 id="参数介绍-1">参数介绍
</h4><p><strong>epfd</strong>：通过 <code>epoll_create</code> 创建的 epoll 文件描述符。</p>
<p><strong>op</strong>：操作类型，<code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code> 和 <code>EPOLL_CTL_DEL</code> 分别表示添加、修改和删除文件描述符的操作。</p>
<p><strong>fd</strong>：要监控的文件描述符。</p>
<p><strong>event</strong>：指定需要监控的事件，类型为 <code>struct epoll_event</code>，它定义了感兴趣的事件类型（如 <code>EPOLLIN</code>、<code>EPOLLOUT</code>、<code>EPOLLRDHUP</code> 等）以及一个用户自定义数据字段。</p>
<h4 id="返回值-1">返回值
</h4><p>0：成功</p>
<p>-1：失败</p>
<h3 id="epoll_wait">epoll_wait
</h3><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</p>
<h4 id="参数介绍-2">参数介绍
</h4><p><strong>epfd</strong>：通过 <code>epoll_create</code> 创建的 epoll 文件描述符。</p>
<p><strong>events</strong>：一个数组，用于存放返回的事件。</p>
<p><strong>maxevents</strong>：指定返回的最大事件数。如果有更多的事件发生，则需要调用多次 <code>epoll_wait</code>。</p>
<p><strong>timeout</strong>：等待时间（毫秒）。如果设置为 <code>-1</code>，则会无限期阻塞，直到有事件发生。如果设置为 <code>0</code>，则立刻返回，不会阻塞。</p>
<h4 id="返回值-2">返回值
</h4><p>0：成功</p>
<p>-1：失败</p>
<h3 id="边缘触发--水平触发">边缘触发 &amp; 水平触发
</h3><ul>
<li>边缘触发et：状态发生变更才通知</li>
<li>水平触发lt：可读/写则通知</li>
</ul>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left">水平触发（LT）</th>
          <th style="text-align: left">边缘触发（ET）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">事件通知</td>
          <td style="text-align: left">一旦满足条件就会持续通知，直到事件被处理完</td>
          <td style="text-align: left">只在状态变化时通知一次，后续不再通知，直到状态再次变化</td>
      </tr>
      <tr>
          <td style="text-align: left">事件类型</td>
          <td style="text-align: left">当文件描述符的状态符合条件时（例如，有数据可读），会持续触发事件，直到条件被处理</td>
          <td style="text-align: left">只会在文件描述符的状态从“未就绪”变为“就绪”时触发一次事件</td>
      </tr>
      <tr>
          <td style="text-align: left">处理要求</td>
          <td style="text-align: left">处理一次事件后，可能会有更多的事件继续被通知</td>
          <td style="text-align: left">处理完事件后，必须尽可能多地处理数据，否则会错过后续事件</td>
      </tr>
      <tr>
          <td style="text-align: left">适用场景</td>
          <td style="text-align: left">适合简单场景，容易处理</td>
          <td style="text-align: left">适合高并发和高性能要求的场景，减少事件通知的次数</td>
      </tr>
  </tbody>
</table></div>
<h4 id="控制">控制
</h4><p>由epoll_ctl注册的event.events控制，<strong>event</strong>：指定需要监控的事件，类型为 <code>struct epoll_event</code>，它定义了感兴趣的事件类型（如 <code>EPOLLIN</code>、<code>EPOLLOUT</code>、<code>EPOLLRDHUP</code> 等）以及一个用户自定义数据字段。</p>
<p>当传入事件类型EPOLLET时，该fd为边缘触发。</p>
<p>默认情况为水平触发。</p>
<ul>
<li>对于redis而言，使用的均为水平触发</li>
<li>nginx中存在边缘触发的使用</li>
</ul>
<h3 id="epoll_wait如何实现等待">epoll_wait如何实现等待
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		   <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec64</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">eavail</span><span class="p">,</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">u64</span> <span class="n">slack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">wait_queue_entry_t</span> <span class="n">wait</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">ktime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">lockdep_assert_irqs_enabled</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果有超时时间，并且不为零，则转换超时时间为ktime格式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">|</span> <span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">slack</span> <span class="o">=</span> <span class="nf">select_estimate_accuracy</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nf">timespec64_to_ktime</span><span class="p">(</span><span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果超时时间为零，表示非阻塞操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 检查是否有可用的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">eavail</span> <span class="o">=</span> <span class="nf">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果有事件，则将事件发送到用户空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">eavail</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">res</span> <span class="o">=</span> <span class="nf">ep_send_events</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 如果发送成功，挂起 NAPI 中断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nf">ep_suspend_napi_irqs</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果超时标志为真，直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">timed_out</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果没有事件，执行忙等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">eavail</span> <span class="o">=</span> <span class="nf">ep_busy_loop</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">timed_out</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">eavail</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 检查是否有信号中断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nf">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 初始化等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">init_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">wait</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">ep_autoremove_wake_function</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 加锁，检查事件是否可用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 再次检查是否有可用事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">eavail</span> <span class="o">=</span> <span class="nf">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eavail</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 如果没有事件，加入到等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">__add_wait_queue_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果没有事件，调用高精度定时器进行等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eavail</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">timed_out</span> <span class="o">=</span> <span class="o">!</span><span class="nf">schedule_hrtimeout_range</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">slack</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">							      <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 设置当前任务为运行状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 被唤醒后检查是否有事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">eavail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果等待队列不为空，移除当前等待条目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">timed_out</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 如果超时，则再次检查等待队列是否为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">eavail</span> <span class="o">=</span> <span class="nf">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 从等待队列中移除当前条目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="总结">总结
</h4><p><strong>阻塞实现</strong>：当没有事件发生且超时条件为 <code>-1</code> 时，<code>ep_poll</code> 会通过将当前进程加入到等待队列中来实现阻塞，直到事件发生或者超时。</p>
<p><strong>忙等待的作用</strong>：忙等待是在没有事件的情况下不断轮询检查事件队列，如果有事件，则立即处理。如果没有事件，则避免过早地阻塞。</p>
<p><strong>等待队列的加入</strong>：在忙等待检查之后，<code>ep_poll</code> 会在确认没有事件且没有超时时，将进程加入等待队列。等待队列保证了进程可以被挂起，直到有事件发生或者超时。</p>
<h4 id="一直没有事件发生的例子">一直没有事件发生的例子
</h4><p><strong>没有事件的情况下，<code>eavail</code> 会持续为 <code>0</code>。</strong></p>
<ul>
<li>ep_events_available，返回0，当 <code>eavail == 0</code> 时，代码会先进入忙等待阶段，并尝试重新检查是否有事件。
<ul>
<li>避免直接进入阻塞，提高执行效率（类似jvm中先轻量级cas锁，满足一定条件后再升级为依赖os的重锁）</li>
</ul>
</li>
<li>如果经过忙等待仍然没有事件，ep_busy_loop返回0，此时 <code>eavail == 0</code> ，<code>epoll</code> 会进入等待队列并阻塞当前线程，直到事件发生。</li>
<li>当进程被唤醒后，<code>eavail</code> 被强制设置为 <code>1</code>，表示进入下一轮事件的处理。</li>
</ul>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E7%94%A8-reids-%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/">
        
        

        <div class="article-details">
            <h2 class="article-title">高性能&amp;高可用 reids-分布式集群</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD-reids-%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/">
        
        

        <div class="article-details">
            <h2 class="article-title">高性能 reids-空间效率</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/zh-cn/p/%E9%AB%98%E6%80%A7%E8%83%BD-reids-%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87/">
        
        

        <div class="article-details">
            <h2 class="article-title">高性能 reids-时间效率</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/zh-cn/p/%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1-%E9%89%B4%E6%9D%83%E6%8E%88%E6%9D%83/">
        
        

        <div class="article-details">
            <h2 class="article-title">权限设计-鉴权授权</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/zh-cn/p/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-orm-spring/">
        
        

        <div class="article-details">
            <h2 class="article-title">开发框架-orm-spring</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            1998 - 
        
        2024 yuwenxin
    </section>
    
    <section class="powerby">
        
            welcome to wenxin-blog <br/>
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
